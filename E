local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")

-- StoredVariables

-- Esp Variable
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")

-- Configurations
local highlightEspEnabled = false
local nameEspEnabled = false
local boxEspEnabled = false
local distanceEspEnabled = false
local healthEspEnabled = false
local espColor = Color3.fromRGB(86, 171, 128)
local espObjects = {}
local espDistanceFormat = "%.1f" -- Format for distance display (1 decimal place)
local maxDistance = 1000 -- Max distance to show ESP
local teamCheckEnabled = true -- Whether to only show enemies

-- Function to safely get player from character
local function getPlayerFromCharacter(character)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character == character then
            return player
        end
    end
    return nil
end

-- Function to check if a player is an enemy (teamcheck)
local function isEnemy(player)
    if not teamCheckEnabled then
        return player ~= Players.LocalPlayer
    end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer or not player or player == localPlayer then
        return false
    end

    local localTeam = localPlayer.Team
    local targetTeam = player.Team

    -- If the game doesn't use teams, treat all players (except self) as enemies
    if Teams:GetChildren() == nil or #Teams:GetChildren() == 0 then
        return true
    end

    -- If teams exist, check if they're different
    return localTeam ~= targetTeam
end

-- Function to calculate distance between two positions
local function calculateDistance(position1, position2)
    if not position1 or not position2 then return 0 end
    return (position1 - position2).Magnitude
end

-- Function to format distance for display
local function formatDistance(distance)
    return string.format(espDistanceFormat, distance)
end

-- Function to update ESP information (distance, health, etc)
local function updateEspInfo()
    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return end
    
    local localRoot = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localRoot then return end
    
    for player, objects in pairs(espObjects) do
        if player and player:IsA("Player") and player.Character then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if humanoidRootPart then
                -- Update distance display
                if distanceEspEnabled then
                    local distance = calculateDistance(localRoot.Position, humanoidRootPart.Position)
                    if distance <= maxDistance then
                        for _, obj in pairs(objects) do
                            if obj:IsA("BillboardGui") and obj.Name == "SilverWareNameEsp" then
                                local textLabel = obj:FindFirstChild("TextLabel")
                                if textLabel then
                                    local displayText = player.Name
                                    if healthEspEnabled and humanoid then
                                        displayText = displayText .. "\nHP: " .. math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
                                    end
                                    if distanceEspEnabled then
                                        displayText = displayText .. "\n" .. formatDistance(distance) .. "m"
                                    end
                                    textLabel.Text = displayText
                                end
                            end
                        end
                    else
                        -- Hide ESP if beyond max distance
                        for _, obj in pairs(objects) do
                            if obj and obj.Parent then
                                obj.Enabled = false
                            end
                        end
                    end
                end
                
                -- Update health color if health ESP is enabled
                if healthEspEnabled and humanoid then
                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                    local healthColor
                    if healthPercent > 0.7 then
                        healthColor = Color3.new(0, 1, 0) -- Green
                    elseif healthPercent > 0.3 then
                        healthColor = Color3.new(1, 1, 0) -- Yellow
                    else
                        healthColor = Color3.new(1, 0, 0) -- Red
                    end
                    
                    for _, obj in pairs(objects) do
                        if obj:IsA("Highlight") then
                            obj.FillColor = healthColor
                            obj.OutlineColor = healthColor
                        elseif obj:IsA("BoxHandleAdornment") then
                            obj.Color3 = healthColor
                        elseif obj:IsA("BillboardGui") and obj:FindFirstChild("TextLabel") then
                            obj.TextLabel.TextColor3 = healthColor
                        end
                    end
                end
            end
        end
    end
end

-- Function to create ESP
local function createEsp(player)
    if not player or not player:IsA("Player") or not player.Character then return end

    local character = player.Character
    if not character or not character.Parent then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoidRootPart or not humanoid then return end

    -- Remove existing ESP if it exists
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Parent then
                obj:Destroy()
            end
        end
        espObjects[player] = nil
    end

    -- Only create ESP for enemies if team check is enabled
    if teamCheckEnabled and not isEnemy(player) then return end

    -- Create new ESP objects
    espObjects[player] = {}

    -- Highlight ESP
    if highlightEspEnabled then
        local highlight = Instance.new("Highlight")
        highlight.Name = "SilverWareHighlight"
        highlight.Adornee = character
        highlight.FillColor = espColor
        highlight.OutlineColor = espColor
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Parent = character
        table.insert(espObjects[player], highlight)
    end

    -- Name ESP (also shows distance and health if enabled)
    if nameEspEnabled or distanceEspEnabled or healthEspEnabled then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "SilverWareNameEsp"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 60) -- Larger to accommodate extra info
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Text = player.Name
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextStrokeTransparency = 0
        textLabel.TextColor3 = espColor
        textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        textLabel.TextScaled = false
        textLabel.TextSize = 14
        textLabel.Font = Enum.Font.GothamBold
        textLabel.TextYAlignment = Enum.TextYAlignment.Top
        textLabel.Parent = billboard
        
        if humanoidRootPart and humanoidRootPart.Parent then
            billboard.Parent = humanoidRootPart
            table.insert(espObjects[player], billboard)
        else
            billboard:Destroy()
        end
    end

    -- Box ESP
    if boxEspEnabled then
        local box = Instance.new("BoxHandleAdornment")
        box.Name = "SilverWareBoxEsp"
        box.Adornee = humanoidRootPart
        box.AlwaysOnTop = true
        box.ZIndex = 10
        box.Size = humanoidRootPart.Size * 1.5
        box.Transparency = 0.5
        box.Color3 = espColor
        
        if humanoidRootPart and humanoidRootPart.Parent then
            box.Parent = humanoidRootPart
            table.insert(espObjects[player], box)
        else
            box:Destroy()
        end
    end
    
    -- Tracer ESP (line from bottom of screen to player)
    if tracerEspEnabled then
        local tracer = Instance.new("Frame")
        tracer.Name = "SilverWareTracerEsp"
        tracer.BackgroundColor3 = espColor
        tracer.BorderSizePixel = 0
        tracer.Size = UDim2.new(0, 1, 0, 1000) -- Long vertical line
        tracer.AnchorPoint = Vector2.new(0.5, 1)
        tracer.Position = UDim2.new(0.5, 0, 1, 0)
        tracer.Parent = game:GetService("CoreGui")
        
        -- Store reference to update position later
        table.insert(espObjects[player], tracer)
    end
end

-- Function to update ESP color
local function updateEspColor(newColor)
    espColor = newColor
    for player, objects in pairs(espObjects) do
        if player and player:IsA("Player") then
            for _, obj in pairs(objects) do
                if obj and obj.Parent then
                    if obj:IsA("Highlight") then
                        if not healthEspEnabled then
                            obj.FillColor = newColor
                            obj.OutlineColor = newColor
                        end
                    elseif obj:IsA("BillboardGui") and obj:FindFirstChild("TextLabel") then
                        if not healthEspEnabled then
                            obj.TextLabel.TextColor3 = newColor
                        end
                    elseif obj:IsA("BoxHandleAdornment") then
                        if not healthEspEnabled then
                            obj.Color3 = newColor
                        end
                    elseif obj:IsA("Frame") and obj.Name == "SilverWareTracerEsp" then
                        obj.BackgroundColor3 = newColor
                    end
                end
            end
        end
    end
end

-- Function to toggle ESP for all players
local function toggleEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        if player and player:IsA("Player") then
            createEsp(player)
        end
    end
end

-- Function to clear all ESP
local function clearEsp()
    for player, objects in pairs(espObjects) do
        if objects then
            for _, obj in pairs(objects) do
                if obj and obj.Parent then
                    obj:Destroy()
                end
            end
        end
    end
    espObjects = {}
end

-- Handle player respawns
local function onCharacterAdded(character, player)
    if not character or not character.Parent then return end
    
    -- Wait for character to fully load
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    local humanoid = character:WaitForChild("Humanoid", 5)
    
    if not humanoidRootPart or not humanoid then return end
    
    -- Only create ESP if at least one ESP type is enabled and player is an enemy (if team check is on)
    local shouldCreateEsp = (highlightEspEnabled or nameEspEnabled or boxEspEnabled or distanceEspEnabled or healthEspEnabled) and
                          (not teamCheckEnabled or isEnemy(player))
    
    if shouldCreateEsp then
        createEsp(player)
    end
    
    -- Handle future respawns
    humanoid.Died:Connect(function()
        -- Clean up ESP when player dies
        if espObjects[player] then
            for _, obj in pairs(espObjects[player]) do
                if obj and obj.Parent then
                    obj:Destroy()
                end
            end
            espObjects[player] = nil
        end
        
        -- Recreate ESP when player respawns if conditions are met
        player.CharacterAdded:Connect(function(newCharacter)
            task.wait(1) -- Wait for character to load
            
            local shouldRecreate = (highlightEspEnabled or nameEspEnabled or boxEspEnabled or distanceEspEnabled or healthEspEnabled) and
                                 (not teamCheckEnabled or isEnemy(player))
            
            if shouldRecreate then
                createEsp(player)
            end
        end)
    end)
end

-- Player added/removed connections
local function onPlayerAdded(player)
    if not player or not player:IsA("Player") then return end
    
    -- Handle initial character
    player.CharacterAdded:Connect(function(character)
        onCharacterAdded(character, player)
    end)
    
    if player.Character then
        coroutine.wrap(onCharacterAdded)(player.Character, player)
    end
end

local function onPlayerRemoving(player)
    if not player or not player:IsA("Player") then return end
    
    -- Clean up ESP when player leaves
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Parent then
                obj:Destroy()
            end
        end
        espObjects[player] = nil
    end
end

-- Initialize for existing players
for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end

-- Connect future players
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Initialize for local player (in case they respawn)
if Players.LocalPlayer and Players.LocalPlayer.Character then
    onCharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer)
end

-- Create a loop to update ESP information
local espUpdateLoop = RunService.RenderStepped:Connect(function()
    if highlightEspEnabled or nameEspEnabled or boxEspEnabled or distanceEspEnabled or healthEspEnabled then
        updateEspInfo()
    end
end)

-- Hitbox Variable
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Player variables
local localPlayer = Players.LocalPlayer
while not localPlayer do
    task.wait()
    localPlayer = Players.LocalPlayer
end

-- Configuration variables
local hitboxSize = 10
local hitboxTransparency = 0.9
local hitboxEnabled = false
local hitboxType = "Both" -- "Both", "Only Hrp", "Only Head"
local hitboxColor = Color3.fromRGB(255, 0, 0)

-- Team detection function
local function isEnemy(player)
    if player == localPlayer then return false end
    
    local teams = game:GetService("Teams"):GetTeams()
    if #teams > 1 then
        if localPlayer.Team == nil or player.Team == nil then
            return true
        end
        return localPlayer.Team ~= player.Team
    else
        return true
    end
end

-- Apply hitbox to a character
local function applyHitbox(character)
    if not character or not hitboxEnabled then return end
    
    local player = Players:GetPlayerFromCharacter(character)
    if player and player == localPlayer then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return end
    
    local isR15 = humanoid and humanoid.RigType == Enum.HumanoidRigType.R15
    
    -- Store original sizes if not already stored
    local function storeOriginalSize(part)
        if not part:FindFirstChild("OriginalSize") then
            local originalSize = Instance.new("Vector3Value")
            originalSize.Name = "OriginalSize"
            originalSize.Value = part.Size
            originalSize.Parent = part
        end
    end

    -- Apply hitbox to a specific part
    local function applyToPart(part)
        if not part then return end
        storeOriginalSize(part)
        part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        part.Transparency = hitboxTransparency
        part.BrickColor = BrickColor.new(hitboxColor)
        part.Material = Enum.Material.ForceField
        part.CanCollide = false
    end

    -- Apply based on selected hitbox type
    if hitboxType == "Both" or hitboxType == "Only Hrp" then
        local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("UpperTorso")
        applyToPart(rootPart)
        
        if isR15 and hitboxType == "Both" then
            local lowerTorso = character:FindFirstChild("LowerTorso")
            applyToPart(lowerTorso)
        end
    end
    
    if hitboxType == "Both" or hitboxType == "Only Head" then
        local head = character:FindFirstChild("Head")
        applyToPart(head)
    end
    
    -- For R15, adjust other parts if "Both" is selected
    if isR15 and hitboxType == "Both" then
        local partsToAdjust = {"UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}
        for _, partName in ipairs(partsToAdjust) do
            local part = character:FindFirstChild(partName)
            applyToPart(part)
        end
    end
end

-- Reset hitbox to original size
local function resetHitbox(character)
    if not character then return end
    
    local player = Players:GetPlayerFromCharacter(character)
    if player and player == localPlayer then return end
    
    local function resetPart(part)
        if part and part:FindFirstChild("OriginalSize") then
            part.Size = part.OriginalSize.Value
            part.Transparency = 1
            part.BrickColor = BrickColor.new("Medium stone grey")
            part.Material = Enum.Material.Plastic
            part.CanCollide = true
        end
    end

    -- Reset all parts regardless of current hitbox type
    local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("UpperTorso")
    resetPart(rootPart)
    
    local head = character:FindFirstChild("Head")
    resetPart(head)
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local isR15 = humanoid and humanoid.RigType == Enum.HumanoidRigType.R15
    
    if isR15 then
        local partsToReset = {"LowerTorso", "UpperTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}
        for _, partName in ipairs(partsToReset) do
            local part = character:FindFirstChild(partName)
            resetPart(part)
        end
    end
end

-- Apply hitboxes to all players
local function applyHitboxesToAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if isEnemy(player) and player.Character then
            applyHitbox(player.Character)
        end
    end
end

-- Reset hitboxes on all players
local function resetHitboxesOnAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            resetHitbox(player.Character)
        end
    end
end

-- Hitbox toggle system
local hitboxCoroutine
local function toggleHitboxes(enabled)
    hitboxEnabled = enabled
    
    if enabled then
        applyHitboxesToAllPlayers()
        
        if not hitboxCoroutine then
            hitboxCoroutine = coroutine.create(function()
                while hitboxEnabled and task.wait(0.5) do
                    applyHitboxesToAllPlayers()
                end
            end)
            coroutine.resume(hitboxCoroutine)
        end
    else
        if hitboxCoroutine then
            coroutine.close(hitboxCoroutine)
            hitboxCoroutine = nil
        end
        resetHitboxesOnAllPlayers()
    end
end

-- Player tracking system
local function trackPlayer(player)
    if not player then return end
    
    if isEnemy(player) then
        player.CharacterAdded:Connect(function(character)
            task.wait(1) -- Wait for character to fully load
            
            local humanoid = character:WaitForChild("Humanoid")
            
            local function updateHitboxState()
                if hitboxEnabled then
                    if humanoid.Health > 0 then
                        applyHitbox(character)
                    else
                        resetHitbox(character)
                    end
                end
            end
            
            updateHitboxState()
            humanoid.HealthChanged:Connect(updateHitboxState)
        end)
        
        if player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                if hitboxEnabled then
                    if humanoid.Health > 0 then
                        applyHitbox(player.Character)
                    else
                        resetHitbox(player.Character)
                    end
                end
            end
        end
    end
end

-- Initialize tracking for all players
for _, player in ipairs(Players:GetPlayers()) do
    trackPlayer(player)
end

-- Player added/removed events
Players.PlayerAdded:Connect(trackPlayer)

-- FPS Counter
local fpsGui = Instance.new("ScreenGui")
fpsGui.Name = "FPSCounterGui"
fpsGui.ResetOnSpawn = false
fpsGui.Enabled = false
fpsGui.Parent = game:GetService("CoreGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 120, 0, 50)
frame.Position = UDim2.new(0, 10, 0, 10)
frame.BackgroundColor3 = Color3.fromRGB(109, 110, 108)
frame.BackgroundTransparency = 0.3
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
frame.Parent = fpsGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12) -- You can adjust the radius as needed
corner.Parent = frame

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 1, 0)
label.BackgroundTransparency = 1
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = false
label.TextSize = 14 -- Adjust this number to make it smaller or larger
label.Font = Enum.Font.Gotham
label.Text = "FPS: 0"
label.Parent = frame

-- FPS Update Loop
local fps = 0
local counter = 0
local lastTick = tick()
local fpsConnection = nil

local function updateFPS()
    counter += 1
    if tick() - lastTick >= 1 then
        fps = counter
        counter = 0
        lastTick = tick()
        label.Text = "FPS: " .. tostring(math.floor(fps))
    end
end

-- Function to toggle FPS counter
local function toggleFpsCounter(enable)
    if enable then
        if not fpsConnection then
            fpsConnection = RunService.RenderStepped:Connect(updateFPS)
        end
        fpsGui.Enabled = true
    else
        if fpsConnection then
            fpsConnection:Disconnect()
            fpsConnection = nil
        end
        fpsGui.Enabled = false
    end
end


-- Notify
local DEFAULT_DURATION = 5
local DEFAULT_COLOR = Color3.fromRGB(0, 170, 255)
local NOTIFICATION_WIDTH = 0.35
local NOTIFICATION_HEIGHT = 70
local ANIMATION_DURATION = 0.5

-- Setup
local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- Create ScreenGui if it doesn't exist
local screenGui = gui:FindFirstChild("NotificationGui") or Instance.new("ScreenGui")
screenGui.Name = "NotificationGui"
screenGui.Parent = gui
screenGui.ResetOnSpawn = false

-- Sound system
local notificationSounds = SoundService:FindFirstChild("NotificationSounds") or Instance.new("Folder")
notificationSounds.Name = "NotificationSounds"
notificationSounds.Parent = SoundService

local soundConfigs = {
    NotificationAppear = {id = 3023237993, volume = 1},
    NotificationDisappear = {id = 18595195017, volume = 1},
    NotificationHover = {id = 7218169592, volume = 0.1},
    NotificationClick = {id = 177266782, volume = 1},
    NotificationPulse = {id = 10066936758, volume = 1}
}

local function playSound(soundName)
    local config = soundConfigs[soundName]
    if not config then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://"..config.id
    sound.Volume = config.volume
    sound.Parent = notificationSounds
    sound:Play()
    
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

-- Notification queue system
local notificationQueue = {}
local isShowingNotification = false

local function showNextNotification()
    if #notificationQueue == 0 or isShowingNotification then return end
    isShowingNotification = true
    
    local notificationData = table.remove(notificationQueue, 1)
    showNotification(notificationData.title, notificationData.message, notificationData.duration, notificationData.color)
end

-- Main notification function
function showNotification(title, message, duration, color)
    duration = duration or DEFAULT_DURATION
    color = color or DEFAULT_COLOR

    -- Play appear sound
    playSound("NotificationAppear")

    -- Main frame
    local frame = Instance.new("Frame")
    frame.Name = "Notification"
    frame.Size = UDim2.new(NOTIFICATION_WIDTH, 0, 0, NOTIFICATION_HEIGHT)
    frame.Position = UDim2.new(1, 10, 0.85, 0)
    frame.AnchorPoint = Vector2.new(1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.BackgroundTransparency = 0.8
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.ZIndex = 10
    frame.ClipsDescendants = true

    -- Shadow effect
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageTransparency = 0.9
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame

    -- Rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    -- Accent line with gradient
    local accent = Instance.new("Frame")
    accent.Name = "Accent"
    accent.Size = UDim2.new(0, 0, 0, 2)
    accent.Position = UDim2.new(0, 0, 0, 0)
    accent.BackgroundColor3 = color
    accent.BorderSizePixel = 0
    accent.ZIndex = frame.ZIndex + 1
    accent.Parent = frame

    -- Gradient effect for accent
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, color),
        ColorSequenceKeypoint.new(1, Color3.new(color.R * 0.7, color.G * 0.7, color.B * 0.7))
    }
    gradient.Rotation = 90
    gradient.Parent = accent

    -- Title label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 180)
    titleLabel.TextTransparency = 1
    titleLabel.TextSize = 16
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Size = UDim2.new(1, -40, 0, 20)
    titleLabel.Position = UDim2.new(0, 10, 0, 8)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.BackgroundTransparency = 1
    titleLabel.ZIndex = frame.ZIndex + 1
    titleLabel.Parent = frame

    -- Message label with text wrapping
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Name = "Message"
    messageLabel.Text = message
    messageLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    messageLabel.TextTransparency = 1
    messageLabel.TextSize = 14
    messageLabel.Font = Enum.Font.Gotham
    messageLabel.Size = UDim2.new(1, -20, 0, 35)
    messageLabel.Position = UDim2.new(0, 10, 0, 30)
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextYAlignment = Enum.TextYAlignment.Top
    messageLabel.BackgroundTransparency = 1
    messageLabel.TextWrapped = true
    messageLabel.ZIndex = frame.ZIndex + 1
    messageLabel.Parent = frame

    -- Close button
    local closeButton = Instance.new("ImageButton")
    closeButton.Name = "CloseButton"
    closeButton.Image = "rbxassetid://3926305904"
    closeButton.ImageRectOffset = Vector2.new(284, 4)
    closeButton.ImageRectSize = Vector2.new(24, 24)
    closeButton.ImageColor3 = Color3.fromRGB(180, 180, 180)
    closeButton.ImageTransparency = 1
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 6)
    closeButton.BackgroundTransparency = 1
    closeButton.ZIndex = frame.ZIndex + 1
    closeButton.Parent = frame

    -- Progress bar for time remaining
    local progressBar = Instance.new("Frame")
    progressBar.Name = "ProgressBar"
    progressBar.Size = UDim2.new(1, 0, 0, 2)
    progressBar.Position = UDim2.new(0, 0, 1, -2)
    progressBar.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    progressBar.BorderSizePixel = 0
    progressBar.ZIndex = frame.ZIndex + 1
    progressBar.Parent = frame
    
    local progressFill = Instance.new("Frame")
    progressFill.Name = "ProgressFill"
    progressFill.Size = UDim2.new(1, 0, 1, 0)
    progressFill.BackgroundColor3 = color
    progressFill.BorderSizePixel = 0
    progressFill.ZIndex = frame.ZIndex + 2
    progressFill.Parent = progressBar
    
    local progressCorner = Instance.new("UICorner")
    progressCorner.CornerRadius = UDim.new(1, 0)
    progressCorner.Parent = progressFill

    -- Glow effect
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.Image = "rbxassetid://5028857084"
    glow.ImageColor3 = color
    glow.ImageTransparency = 1
    glow.ScaleType = Enum.ScaleType.Slice
    glow.SliceCenter = Rect.new(24, 24, 24, 24)
    glow.Size = UDim2.new(1, 40, 1, 40)
    glow.Position = UDim2.new(0.5, -20, 0.5, -20)
    glow.AnchorPoint = Vector2.new(0.5, 0.5)
    glow.BackgroundTransparency = 1
    glow.ZIndex = frame.ZIndex - 1
    glow.Parent = frame

    -- Ripple effect
    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = Color3.new(1, 1, 1)
    ripple.BackgroundTransparency = 0.9
    ripple.ZIndex = frame.ZIndex + 2
    local rippleCorner = Instance.new("UICorner")
    rippleCorner.CornerRadius = UDim.new(1, 0)
    rippleCorner.Parent = ripple
    ripple.Parent = frame

    -- Pulse animation for accent line
    local pulseConnection
    local function startPulse()
        playSound("NotificationPulse")
        
        local targetColor = Color3.new(color.R * 1.2, color.G * 1.2, color.B * 1.2)
        local pulseIn = TweenService:Create(accent, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, true), {
            BackgroundColor3 = targetColor
        })
        pulseIn:Play()
    end

    -- Animation sequences
    local function playEntranceAnimations()
        -- Slide in animation with bounce
        local slideIn = TweenService:Create(frame, TweenInfo.new(ANIMATION_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Position = UDim2.new(1, -10, 0.85, 0),
            BackgroundTransparency = 0.1
        })
        
        -- Shadow pop effect
        local shadowPop = TweenService:Create(shadow, TweenInfo.new(ANIMATION_DURATION * 0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            ImageTransparency = 0.6,
            Size = UDim2.new(1, 30, 1, 30),
            Position = UDim2.new(0, -15, 0, -15)
        })
        
        -- Glow effect
        local glowFadeIn = TweenService:Create(glow, TweenInfo.new(ANIMATION_DURATION, Enum.EasingStyle.Quad), {
            ImageTransparency = 0.8
        })
        
        -- Ripple effect
        local rippleExpand = TweenService:Create(ripple, TweenInfo.new(ANIMATION_DURATION * 0.6, Enum.EasingStyle.Quad), {
            Size = UDim2.new(2, 0, 2, 0),
            BackgroundTransparency = 1
        })
        
        -- Content fade in
        local fadeIn = TweenService:Create(titleLabel, TweenInfo.new(ANIMATION_DURATION * 0.8, Enum.EasingStyle.Quad), {
            TextTransparency = 0
        })
        local fadeIn2 = TweenService:Create(messageLabel, TweenInfo.new(ANIMATION_DURATION * 0.8, Enum.EasingStyle.Quad), {
            TextTransparency = 0
        })
        local fadeIn3 = TweenService:Create(closeButton, TweenInfo.new(ANIMATION_DURATION * 0.8, Enum.EasingStyle.Quad), {
            ImageTransparency = 0
        })
        
        -- Accent line animation
        local accentGrow = TweenService:Create(accent, TweenInfo.new(ANIMATION_DURATION * 0.8, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(1, 0, 0, 2)
        })
        
        -- Play animations
        slideIn:Play()
        shadowPop:Play()
        rippleExpand:Play()
        glowFadeIn:Play()
        
        task.wait(ANIMATION_DURATION * 0.1)
        accentGrow:Play()
        
        task.wait(ANIMATION_DURATION * 0.15)
        fadeIn:Play()
        
        task.wait(ANIMATION_DURATION * 0.05)
        fadeIn2:Play()
        
        task.wait(ANIMATION_DURATION * 0.05)
        fadeIn3:Play()
        
        -- Start pulse animation after everything is shown
        task.delay(ANIMATION_DURATION * 0.6, startPulse)
    end

    -- Hover effects
    local function setupHoverEffects()
        local hoverScale = 1.02
        
        frame.MouseEnter:Connect(function()
            playSound("NotificationHover")
            
            TweenService:Create(frame, TweenInfo.new(0.2), {
                Size = UDim2.new(NOTIFICATION_WIDTH * hoverScale, 0, 0, NOTIFICATION_HEIGHT * hoverScale)
            }):Play()
            TweenService:Create(shadow, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 30 * hoverScale, 1, 30 * hoverScale),
                Position = UDim2.new(0, -15 * hoverScale, 0, -15 * hoverScale)
            }):Play()
        end)
        
        frame.MouseLeave:Connect(function()
            TweenService:Create(frame, TweenInfo.new(0.2), {
                Size = UDim2.new(NOTIFICATION_WIDTH, 0, 0, NOTIFICATION_HEIGHT)
            }):Play()
            TweenService:Create(shadow, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 30, 1, 30),
                Position = UDim2.new(0, -15, 0, -15)
            }):Play()
        end)

        -- Close button hover effects
        closeButton.MouseEnter:Connect(function()
            playSound("NotificationHover")
            
            TweenService:Create(closeButton, TweenInfo.new(0.1), {
                ImageColor3 = Color3.new(1, 1, 1),
                Rotation = 90,
                Size = UDim2.new(0, 22, 0, 22),
                Position = UDim2.new(1, -26, 0, 5)
            }):Play()
        end)
        
        closeButton.MouseLeave:Connect(function()
            TweenService:Create(closeButton, TweenInfo.new(0.1), {
                ImageColor3 = Color3.fromRGB(180, 180, 180),
                Rotation = 0,
                Size = UDim2.new(0, 20, 0, 20),
                Position = UDim2.new(1, -25, 0, 6)
            }):Play()
        end)
    end

    -- Close functionality
    local closing = false
    local function close()
        if closing then return end
        closing = true
        
        playSound("NotificationDisappear")
        
        -- Stop pulse animation
        if pulseConnection then
            pulseConnection:Disconnect()
        end
        
        -- Create close ripple
        local closeRipple = ripple:Clone()
        closeRipple.BackgroundTransparency = 0.95
        closeRipple.Size = UDim2.new(0, 0, 0, 0)
        closeRipple.Position = UDim2.new(
            UserInputService:GetMouseLocation().X / frame.AbsoluteSize.X,
            0,
            (UserInputService:GetMouseLocation().Y - frame.AbsolutePosition.Y) / frame.AbsoluteSize.Y,
            0
        )
        closeRipple.AnchorPoint = Vector2.new(0.5, 0.5)
        closeRipple.Parent = frame
        
        local rippleOut = TweenService:Create(closeRipple, TweenInfo.new(0.6, Enum.EasingStyle.Quad), {
            Size = UDim2.new(2, 0, 2, 0),
            BackgroundTransparency = 1
        })
        rippleOut:Play()
        rippleOut.Completed:Connect(function()
            closeRipple:Destroy()
        end)
        
        -- Shake effect
        local shakeOffset = 5
        for i = 1, 3 do
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 + shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 - shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            shakeOffset = shakeOffset * 0.6
        end
        
        -- Fade out content
        local fadeOut = TweenService:Create(titleLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut2 = TweenService:Create(messageLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut3 = TweenService:Create(closeButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            ImageTransparency = 1
        })
        
        fadeOut:Play()
        fadeOut2:Play()
        fadeOut3:Play()
        
        -- Slide out frame
        task.wait(0.15)
        local slideOut = TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Position = UDim2.new(1, 10, 0.85, 0),
            BackgroundTransparency = 0.8
        })
        
        -- Shrink accent line
        local accentShrink = TweenService:Create(accent, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 0, 0, 2)
        })
        
        -- Shadow fade out
        local shadowFadeOut = TweenService:Create(shadow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 0.9,
            Size = UDim2.new(1, 20, 1, 20),
            Position = UDim2.new(0, -10, 0, -10)
        })
        
        -- Glow fade out
        local glowFadeOut = TweenService:Create(glow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 1
        })
        
        slideOut:Play()
        accentShrink:Play()
        shadowFadeOut:Play()
        glowFadeOut:Play()
        
        slideOut.Completed:Wait()
        frame:Destroy()
        isShowingNotification = false
        showNextNotification()
    end

    closeButton.MouseButton1Click:Connect(function()
        playSound("NotificationClick")
        close()
    end)

    -- Progress bar animation
    local progressTween = TweenService:Create(progressFill, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
        Size = UDim2.new(0, 0, 1, 0)
    })
    progressTween:Play()

    -- Auto-close after duration
    task.delay(duration, function()
        close()
    end)

    -- Play entrance animations
    playEntranceAnimations()
    setupHoverEffects()
end

-- Queue system function
function queueNotification(title, message, duration, color)
    table.insert(notificationQueue, {
        title = title,
        message = message,
        duration = duration or DEFAULT_DURATION,
        color = color or DEFAULT_COLOR
    })
    
    if not isShowingNotification then
        showNextNotification()
    end
end

-- Example usage
queueNotification("Made By Hmmm5650", "Script Started", 3, Color3.fromRGB(161, 165, 162))

local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()
local Window = Luna:CreateWindow({
    Name = "SilverWareüç¥",
    Subtitle = "(v1.1)",
    LogoID = "98445694743887",
    LoadingEnabled = true,
    LoadingTitle = "Starting SilverWareüç¥",
    LoadingSubtitle = "[ Ver, 1.1 ]",
    ConfigSettings = {
        RootFolder = nil,
        ConfigFolder = "SliverWareConfig"
    },
    KeySystem = false
})

local Tab = Window:CreateTab({
    Name = "Settings",
    Icon = "settings",
    ImageSource = "Material",
    ShowTitle = true
})

local Button = Tab:CreateButton({
	Name = "AntiKick",
	Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
    	end
})

local Button = Tab:CreateButton({
	Name = "AntiKick 2",
	Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/welomenchaina/Loader/refs/heads/main/AntiKickLoader",true))()
    	end
})

-- FullBright ToggleVariable
local Lighting = game:GetService("Lighting")

-- Store original lighting settings to restore them later
local originalSettings = {
	Brightness = Lighting.Brightness,
	ClockTime = Lighting.ClockTime,
	FogEnd = Lighting.FogEnd,
	GlobalShadows = Lighting.GlobalShadows,
	Ambient = Lighting.Ambient
}

local Toggle = Tab:CreateToggle({
	Name = "FullBright",
	Description = nil,
	CurrentValue = false,
	Callback = function(Value)
		if Value then
			Lighting.Brightness = 5
			Lighting.ClockTime = 12
			Lighting.FogEnd = 100000
			Lighting.GlobalShadows = false
			Lighting.Ambient = Color3.new(1, 1, 1)
		else
			-- Restore original lighting settings
			for prop, val in pairs(originalSettings) do
				Lighting[prop] = val
			end
		end
	end
}, "Toggle")

local Button = Tab:CreateButton({
    Name = "Reset WalkSpeed",
    Description = "Resets your WalkSpeed to default (16)",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = 16
        end
    end
})

local Slider = Tab:CreateSlider({
    Name = "WalkSpeed Slider",
    Range = {0, 200},
    Increment = 5,
    CurrentValue = 16,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = Value
        end
    end
}, "WalkSpeedSlider")

Tab:CreateDivider()

local Button = Tab:CreateButton({
	Name = "Show Console",
	Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         game:GetService("StarterGui"):SetCore("DevConsoleVisible",true)
    	end
})

local Tab = Window:CreateTab({
	Name = "PlayerList",
	Icon = "group",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
    Name = "Copy Player Username",
    Description = "Click to show player list",
    Callback = function()
        -- Clear any existing buttons (if needed)
        -- (Depends on your UI library, some may require manual cleanup)
        
        -- Get all players
        local players = game:GetService("Players"):GetPlayers()
        
        -- Create a button for each player
        for _, player in ipairs(players) do
            Tab:CreateButton({
                Name = player.Name,
                Description = "Click to copy username",
                Callback = function()
                    -- Copy username to clipboard
                    if setclipboard then
                        setclipboard(player.Name)
                    else
                        -- Fallback for non-exploit environments (Roblox Studio)
                        print("[Copied] " .. player.Name)
                    end
                    
                    -- Optional: Notify the user
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = "Copied!",
                        Text = player.Name .. " copied to clipboard",
                        Duration = 3,
                    })
                end
            })
        end
    end
})

Tab:CreateDivider()

local Tab = Window:CreateTab({
    Name = "FpsBooster",
    Icon = "build",
    ImageSource = "Material",
    ShowTitle = true
})

-- In your Toggle callback:
local Toggle = Tab:CreateToggle({
    Name = "Show FPSCounter",
    Description = nil,
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            fpsGui.Enabled = true
            -- Only create a new connection if one doesn't exist
            if not fpsConnection then
                fpsConnection = RunService.RenderStepped:Connect(updateFPS)
            end
        else
            fpsGui.Enabled = false
            -- Disconnect the connection if it exists
            if fpsConnection then
                fpsConnection:Disconnect()
                fpsConnection = nil
            end
        end
    end
}, "Toggle")

Tab:CreateDivider()

-- Main AntiLag Button
local Button = Tab:CreateButton({
    Name = "AntiLag",
    Description = "Optimizes game performance with multiple tweaks",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/zJztwUg1", true))()
    end
})

local Button = Tab:CreateButton({
    Name = "AntiLag 2",
    Description = "Optimizes game performance with multiple tweaks",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/8YZ2cc6V"))()
    end
})

Tab:CreateDivider()

-- Remove Fog Toggle
local RemoveFogToggle = Tab:CreateToggle({
    Name = "Remove Fog",
    Description = "Disables all fog effects in the game",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            game:GetService("Lighting").FogEnd = 9e9
            game:GetService("Lighting").FogStart = 9e9
        else
            game:GetService("Lighting").FogEnd = 1000
            game:GetService("Lighting").FogStart = 0
        end
    end
})

-- Low Quality Textures Toggle
local LowQualityToggle = Tab:CreateToggle({
    Name = "Low Quality Textures",
    Description = "Reduces texture quality for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            settings().Rendering.QualityLevel = 1
        else
            settings().Rendering.QualityLevel = 21
        end
    end
})

-- Disable Shadows Toggle
local ShadowsToggle = Tab:CreateToggle({
    Name = "Disable Shadows",
    Description = "Turns off all shadow effects",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            game:GetService("Lighting").GlobalShadows = false
        else
            game:GetService("Lighting").GlobalShadows = true
        end
    end
})

-- Remove Particles Toggle
local ParticlesToggle = Tab:CreateToggle({
    Name = "Remove Particles",
    Description = "Disables all particle effects",
    CurrentValue = false,
    Callback = function(Value)
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("ParticleEmitter") then
                v.Enabled = not Value
            end
        end
    end
})

-- Disable Terrain Water Toggle
local WaterToggle = Tab:CreateToggle({
    Name = "Disable Terrain Water",
    Description = "Removes water effects from terrain",
    CurrentValue = false,
    Callback = function(Value)
        workspace.Terrain.WaterWaveSize = Value and 0 or 0.1
        workspace.Terrain.WaterWaveSpeed = Value and 0 or 10
        workspace.Terrain.WaterReflectance = Value and 0 or 0.5
    end
})

-- Reduce Render Distance Toggle
local RenderDistanceToggle = Tab:CreateToggle({
    Name = "Reduce Render Distance",
    Description = "Lowers how far you can see objects",
    CurrentValue = false,
    Callback = function(Value)
        local camera = workspace.CurrentCamera
        if camera and camera:FindFirstChild("CameraSubject") then
            camera.CameraSubject.Distance = Value and 50 or 500
        end
    end
})

-- Disable Post-Processing Toggle
local PostProcessingToggle = Tab:CreateToggle({
    Name = "Disable Post-Processing",
    Description = "Turns off bloom, depth of field, etc.",
    CurrentValue = false,
    Callback = function(Value)
        local lighting = game:GetService("Lighting")
        
        local function toggleEffect(effectName)
            local effect = lighting:FindFirstChild(effectName)
            if effect then
                effect.Enabled = not Value
            end
        end

        toggleEffect("Bloom")
        toggleEffect("Blur")
        toggleEffect("ColorCorrection")
        toggleEffect("DepthOfField")
        toggleEffect("SunRays")
    end
})

Tab:CreateDivider()

local Button = Tab:CreateButton({
	Name = "Reset FpsCap",
	Description = "sets FpsCap to 60", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         setfpscap(60)
    	end
})

local Slider = Tab:CreateSlider({
	Name = "SetFpsCap",
	Range = {0, 9000}, -- The Minimum And Maximum Values Respectively
	Increment = 5, -- Basically The Changing Value/Rounding Off
	CurrentValue = 60, -- The Starting Value
    	Callback = function(Value)
       	 setfpscap(Value)
    	end
}, "Slider") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

-- Create the Visuals tab
local Tab = Window:CreateTab({
    Name = "Visuals",
    Icon = "visibility",
    ImageSource = "Material",
    ShowTitle = true
})

local HighlightToggle = Tab:CreateToggle({
    Name = "Highlight ESP",
    Description = "Highlights player characters",
    CurrentValue = highlightEspEnabled,
    Callback = function(Value)
        highlightEspEnabled = Value
        toggleEsp()
    end
}, "HighlightToggle")

local NameToggle = Tab:CreateToggle({
    Name = "Name ESP",
    Description = "Shows player names above characters",
    CurrentValue = nameEspEnabled,
    Callback = function(Value)
        nameEspEnabled = Value
        toggleEsp()
    end
}, "NameToggle")

local BoxToggle = Tab:CreateToggle({
    Name = "Box ESP",
    Description = "Draws boxes around player characters",
    CurrentValue = boxEspEnabled,
    Callback = function(Value)
        boxEspEnabled = Value
        toggleEsp()
    end
}, "BoxToggle")

local DistanceToggle = Tab:CreateToggle({
    Name = "Distance ESP",
    Description = "Shows distance to players",
    CurrentValue = distanceEspEnabled,
    Callback = function(Value)
        distanceEspEnabled = Value
        toggleEsp()
    end
}, "DistanceToggle")

local HealthToggle = Tab:CreateToggle({
    Name = "Health ESP",
    Description = "Shows health and changes color based on health",
    CurrentValue = healthEspEnabled,
    Callback = function(Value)
        healthEspEnabled = Value
        toggleEsp()
    end
}, "HealthToggle")

Tab:CreateDivider()

local TeamCheckToggle = Tab:CreateToggle({
    Name = "Team Check",
    Description = "Only show ESP for enemy team",
    CurrentValue = teamCheckEnabled,
    Callback = function(Value)
        teamCheckEnabled = Value
        toggleEsp()
    end
}, "TeamCheckToggle")

local ColorPicker = Tab:CreateColorPicker({
    Name = "ESP Color",
    Description = "Color for ESP elements",
    Color = espColor,
    Callback = function(Value)
        updateEspColor(Value)
    end
}, "EspColorPicker")

local MaxDistanceInput = Tab:CreateInput({
    Name = "Max Distance",
    Description = "Maximum distance to show ESP (in studs)",
    PlaceholderText = tostring(maxDistance),
    CurrentValue = tostring(maxDistance),
    Numeric = true,
    Callback = function(Text)
        local num = tonumber(Text)
        if num then
            maxDistance = num
            toggleEsp()
        end
    end
}, "MaxDistanceInput")

local ClearEspButton = Tab:CreateButton({
    Name = "Clear All ESP",
    Description = "Removes all ESP elements",
    Callback = function()
        clearEsp()
    end
}, "ClearEspButton")


local Slider = Tab:CreateSlider({
    Name = "FOV Slider",
    Range = {0, 120},
    Increment = 1,
    CurrentValue = 70,
    Callback = function(Value)
        game.Workspace.CurrentCamera.FieldOfView = Value
    end
}, "FOVSlider")

local Tab = Window:CreateTab({
	Name = "Aimlock",
	Icon = "gps_fixed",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Toggle = Tab:CreateToggle({
    Name = "StartAimlock",
    Description = "Boots Up Aimlock",
    CurrentValue = false,
    Callback = function(Value)
        -- Store references to all the UI elements
        if not _G.AimlockUI then
            _G.AimlockUI = {
                Inputs = {},
                ColorPicker = nil,
                ScreenGui = nil,
                AimAssist = {
                    Active = false,
                    Smoothness = 0.3,
                    FOVSize = 150,
                    MaxDistance = 1000,
                    TargetColor = Color3.fromRGB(255, 0, 0),
                    TargetTransparency = 0.7
                }
            }
        end
        
        if Value then
            -- Create the aimlock GUI if it doesn't exist
            if not _G.AimlockUI.ScreenGui or not _G.AimlockUI.ScreenGui.Parent then
                -- Get required services
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                local UserInputService = game:GetService("UserInputService")
                local TweenService = game:GetService("TweenService")

                -- Get local player
                local localPlayer = Players.LocalPlayer
                local playerGui = localPlayer:WaitForChild("PlayerGui")

                -- Create UI elements
                local screenGui = Instance.new("ScreenGui")
                screenGui.Parent = playerGui
                screenGui.ResetOnSpawn = false
                screenGui.Name = "AimLockUiLuau"
                _G.AimlockUI.ScreenGui = screenGui

                -- Control panel
                local controlPanel = Instance.new("Frame")
                controlPanel.Size = UDim2.new(0, 120, 0, 50)
                controlPanel.Position = UDim2.new(0, 20, 0, 20)
                controlPanel.BackgroundColor3 = Color3.fromRGB(109, 110, 108)
                controlPanel.BackgroundTransparency = 0.3
                controlPanel.Active = true
                controlPanel.Parent = screenGui

                -- Round corners
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0.3, 0)
                corner.Parent = controlPanel

                -- Toggle button
                local toggleButton = Instance.new("TextButton")
                toggleButton.Size = UDim2.new(1, 0, 1, 0)
                toggleButton.Text = "AimLock: OFF"
                toggleButton.BackgroundTransparency = 1
                toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                toggleButton.TextSize = 14
                toggleButton.Font = Enum.Font.Gotham
                toggleButton.Parent = controlPanel

                -- Highlight when active
                local outline = Instance.new("UIStroke")
                outline.Thickness = 2
                outline.Color = Color3.fromRGB(0, 255, 0)
                outline.Enabled = false
                outline.Parent = controlPanel

                -- Target indicator
                local targetIndicator = Instance.new("Frame")
                targetIndicator.Size = UDim2.new(0, _G.AimlockUI.AimAssist.FOVSize, 0, _G.AimlockUI.AimAssist.FOVSize)
                targetIndicator.Position = UDim2.new(0.5, 0, 0.5, 0)
                targetIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
                targetIndicator.BackgroundTransparency = 1
                targetIndicator.Parent = screenGui

                local targetOutline = Instance.new("UIStroke")
                targetOutline.Thickness = 2
                targetOutline.Color = _G.AimlockUI.AimAssist.TargetColor
                targetOutline.Transparency = _G.AimlockUI.AimAssist.TargetTransparency
                targetOutline.Parent = targetIndicator

                local targetCorner = Instance.new("UICorner")
                targetCorner.CornerRadius = UDim.new(1, 0)
                targetCorner.Parent = targetIndicator

                -- Toggle functionality
                local aimAssistActive = false
                local smoothness = _G.AimlockUI.AimAssist.Smoothness
                local maxDistance = _G.AimlockUI.AimAssist.MaxDistance
                local fovSize = _G.AimlockUI.AimAssist.FOVSize

                local function updateToggle()
                    aimAssistActive = _G.AimlockUI.AimAssist.Active
                    outline.Enabled = aimAssistActive
                    toggleButton.Text = aimAssistActive and "AimLock: ON" or "AimLock: OFF"
                    
                    -- Visual feedback
                    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local tween = TweenService:Create(
                        controlPanel,
                        tweenInfo,
                        {BackgroundColor3 = aimAssistActive and Color3.fromRGB(40, 40, 40) or Color3.fromRGB(30, 30, 30)}
                    )
                    tween:Play()
                end

                toggleButton.MouseButton1Click:Connect(function()
                    _G.AimlockUI.AimAssist.Active = not _G.AimlockUI.AimAssist.Active
                    updateToggle()
                end)

                -- Enemy check function
                local function isEnemyForAimAssist(player)
                    if player == localPlayer then return false end
                    if not player.Character then return false end
                    
                    if game:GetService("Teams") and #game:GetService("Teams"):GetTeams() > 1 then
                        local localTeam = localPlayer.Team
                        local playerTeam = player.Team
                        return localTeam ~= nil and playerTeam ~= nil and localTeam ~= playerTeam
                    else
                        return true -- Assume all players are enemies in non-team games
                    end
                end

                -- Visibility check function
                local function isVisible(targetPosition, character)
                    local localCharacter = localPlayer.Character
                    if not localCharacter then return false end
                    
                    local rootPart = localCharacter:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return false end
                    
                    local direction = (targetPosition - rootPart.Position).Unit
                    local ray = Ray.new(rootPart.Position + direction * 2, direction * maxDistance)
                    
                    local ignoreList = {localCharacter}
                    local hitPart, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                    
                    if hitPart then
                        local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
                        return hitCharacter == character
                    end
                    return false
                end

                -- Find best target function
                local function findBestTarget()
                    local bestTarget = nil
                    local closestDistance = math.huge
                    local localCharacter = localPlayer.Character
                    
                    if not localCharacter then return nil end
                    
                    local rootPart = localCharacter:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return nil end
                    
                    local camera = workspace.CurrentCamera
                    if not camera then return nil end
                    
                    local targetCenter = targetIndicator.AbsolutePosition + (targetIndicator.AbsoluteSize / 2)
                    local targetRadius = fovSize / 2

                    for _, player in pairs(Players:GetPlayers()) do
                        if isEnemyForAimAssist(player) and player.Character then
                            local character = player.Character
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if humanoid and humanoid.Health <= 0 then continue end
                            
                            local enemyRoot = character:FindFirstChild("HumanoidRootPart")
                            local head = character:FindFirstChild("Head")
                            
                            if enemyRoot then
                                local screenPosition, onScreen = camera:WorldToScreenPoint(enemyRoot.Position)
                                if onScreen then
                                    local distanceFromCenter = (Vector2.new(screenPosition.X, screenPosition.Y) - targetCenter).Magnitude
                                    local distanceFromPlayer = (rootPart.Position - enemyRoot.Position).Magnitude
                                    
                                    if distanceFromCenter <= targetRadius 
                                       and distanceFromPlayer <= maxDistance 
                                       and distanceFromCenter < closestDistance 
                                       and isVisible(enemyRoot.Position, character) then
                                        
                                        closestDistance = distanceFromCenter
                                        bestTarget = {
                                            player = player,
                                            root = enemyRoot,
                                            head = head
                                        }
                                    end
                                end
                            end
                        end
                    end
                    
                    return bestTarget
                end

                -- Aim assist functionality
                local aimAssistConnection
                aimAssistConnection = RunService.RenderStepped:Connect(function()
                    if _G.AimlockUI.AimAssist.Active then
                        local target = findBestTarget()
                        
                        if target and target.root then
                            local camera = workspace.CurrentCamera
                            if camera then
                                -- Prioritize head if available
                                local targetPosition = target.head and target.head.Position or target.root.Position
                                local cameraPosition = camera.CFrame.Position
                                local targetCFrame = CFrame.new(cameraPosition, targetPosition)
                                
                                -- Smooth aiming
                                camera.CFrame = camera.CFrame:Lerp(targetCFrame, _G.AimlockUI.AimAssist.Smoothness)
                                
                                -- Visual feedback
                                targetOutline.Color = Color3.fromRGB(0, 255, 0)
                            end
                        else
                            -- Reset visual feedback when no target
                            targetOutline.Color = _G.AimlockUI.AimAssist.TargetColor
                        end
                    end
                end)

                -- Draggable UI functionality
                local isDragging = false
                local dragStartPosition = Vector2.new(0, 0)
                local dragStartOffset = UDim2.new(0, 0, 0, 0)

                controlPanel.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        isDragging = true
                        dragStartPosition = input.Position
                        dragStartOffset = controlPanel.Position
                        
                        -- Visual feedback
                        controlPanel.BackgroundTransparency = 0.2
                    end
                end)

                controlPanel.InputChanged:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
                        local dragDelta = input.Position - dragStartPosition
                        controlPanel.Position = UDim2.new(
                            dragStartOffset.X.Scale, 
                            dragStartOffset.X.Offset + dragDelta.X, 
                            dragStartOffset.Y.Scale, 
                            dragStartOffset.Y.Offset + dragDelta.Y
                        )
                    end
                end)

                UserInputService.InputEnded:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        isDragging = false
                        controlPanel.BackgroundTransparency = 0.3
                    end
                end)

                -- Cleanup when character respawns
                localPlayer.CharacterAdded:Connect(function()
                    if not screenGui:IsDescendantOf(playerGui) then
                        screenGui.Parent = playerGui
                    end
                end)

                -- Store connection for cleanup
                _G.AimlockUI.AimAssist.Connection = aimAssistConnection
                _G.AimlockUI.AimAssist.TargetIndicator = targetIndicator
                _G.AimlockUI.AimAssist.TargetOutline = targetOutline
                _G.AimlockUI.AimAssist.UpdateToggle = updateToggle
            else
                -- If GUI exists but is hidden, show it
                _G.AimlockUI.ScreenGui.Enabled = true
                _G.AimlockUI.AimAssist.UpdateToggle()
            end
        else
            -- Hide the GUI when toggle is off
            if _G.AimlockUI.ScreenGui then
                _G.AimlockUI.ScreenGui.Enabled = false
            end
        end
    end
}, "Toggle")

Tab:CreateDivider()

-- Input for changing aimlock circle size
local Input1 = Tab:CreateInput({
    Name = "Fov Size",
    Description = "Circle size (10-1000)",
    PlaceholderText = tostring(_G.AimlockUI and _G.AimlockUI.AimAssist.FOVSize or 150),
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 4,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local newSize = tonumber(Text)
            if newSize > 10 and newSize < 1000 then
                _G.AimlockUI.AimAssist.FOVSize = newSize
                if _G.AimlockUI.AimAssist.TargetIndicator then
                    _G.AimlockUI.AimAssist.TargetIndicator.Size = UDim2.new(0, newSize, 0, newSize)
                end
            end
        end
    end
}, "Input1")

-- Input for changing aimlock circle transparency
local Input2 = Tab:CreateInput({
    Name = "Fov Transparency",
    Description = "0-1 (0 = solid, 1 = invisible)",
    PlaceholderText = tostring(_G.AimlockUI and _G.AimlockUI.AimAssist.TargetTransparency or 0.7),
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local transparency = tonumber(Text)
            if transparency >= 0 and transparency <= 1 then
                _G.AimlockUI.AimAssist.TargetTransparency = transparency
                if _G.AimlockUI.AimAssist.TargetOutline then
                    _G.AimlockUI.AimAssist.TargetOutline.Transparency = transparency
                end
            end
        end
    end
}, "Input2")

-- Input for changing aimlock strength
local Input3 = Tab:CreateInput({
    Name = "Aimlock Strength",
    Description = "0.1-1 (higher = stronger)",
    PlaceholderText = tostring(_G.AimlockUI and _G.AimlockUI.AimAssist.Smoothness or 0.3),
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local strength = tonumber(Text)
            if strength >= 0.1 and strength <= 1 then
                _G.AimlockUI.AimAssist.Smoothness = strength
            end
        end
    end
}, "Input3")

Tab:CreateDivider()

-- Color picker for changing aimlock circle color
local ColorPicker = Tab:CreateColorPicker({
    Name = "FovColor",
    Color = _G.AimlockUI and _G.AimlockUI.AimAssist.TargetColor or Color3.fromRGB(255, 0, 0),
    Flag = "AimlockColorPicker",
    Callback = function(Value)
        if _G.AimlockUI and _G.AimlockUI.AimAssist then
            _G.AimlockUI.AimAssist.TargetColor = Value
            if _G.AimlockUI.AimAssist.TargetOutline then
                _G.AimlockUI.AimAssist.TargetOutline.Color = Value
            end
        end
    end
}, "ColorPicker")


local Tab = Window:CreateTab({
    Name = "Hitbox Expansion",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local Label = Tab:CreateLabel({
	Text = "[ May Lag On Low-Ends ]",
	Style = 2 -- Luna Labels Have 3 Styles : A Basic Label, A Green Information Label and A Red Warning Label. Look At The Following Image For More Details
})

local Label = Tab:CreateLabel({
	Text = "[ This May Get You Banned ]",
	Style = 3 -- Luna Labels Have 3 Styles : A Basic Label, A Green Information Label and A Red Warning Label. Look At The Following Image For More Details
})

-- UI Integration
local Toggle = Tab:CreateToggle({
    Name = "Start HBE",
    Description = nil,
    CurrentValue = false,
    Callback = function(Value)
        toggleHitboxes(Value)
    end
}, "Toggle")

Tab:CreateDivider()

local Input = Tab:CreateInput({
    Name = "Hitbox Size (textbox)",
    Description = nil,
    PlaceholderText = "10",
    CurrentValue = tostring(hitboxSize),
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        local newSize = tonumber(Text)
        if newSize and newSize >= 1 and newSize <= 50 then
            hitboxSize = newSize
            if hitboxEnabled then
                applyHitboxesToAllPlayers()
            end
        end
    end
}, "Input")

local Slider = Tab:CreateSlider({
    Name = "Hitbox Size (Slider)",
    Range = {1, 50},
    Increment = 1,
    CurrentValue = hitboxSize,
    Callback = function(Value)
        hitboxSize = Value
        if hitboxEnabled then
            applyHitboxesToAllPlayers()
        end
    end
}, "Slider")

local Input = Tab:CreateInput({
    Name = "Hitbox Transparency",
    Description = nil,
    PlaceholderText = "0.9",
    CurrentValue = tostring(hitboxTransparency),
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        local newTransparency = tonumber(Text)
        if newTransparency and newTransparency >= 0 and newTransparency <= 1 then
            hitboxTransparency = newTransparency
            if hitboxEnabled then
                applyHitboxesToAllPlayers()
            end
        end
    end
}, "Input")

Tab:CreateDivider()

local Dropdown = Tab:CreateDropdown({
    Name = "Select Hitbox Type",
    Description = nil,
    Options = {"Both", "Only Hrp", "Only Head"},
    CurrentOption = {"Both"},
    MultipleOptions = false,
    Callback = function(Option)
        hitboxType = Option
        if hitboxEnabled then
            applyHitboxesToAllPlayers()
        end
    end
}, "Dropdown")

local ColorPicker = Tab:CreateColorPicker({
    Name = "Hitbox Color",
    Color = hitboxColor,
    Callback = function(Value)
        hitboxColor = Value
        if hitboxEnabled then
            applyHitboxesToAllPlayers()
        end
    end
}, "ColorPicker")

-- Cleanup function
local function cleanup()
    resetHitboxesOnAllPlayers()
    if hitboxCoroutine then
        coroutine.close(hitboxCoroutine)
    end
end

-- Store cleanup function
getgenv().HitbloxCleanup = cleanup

local Tab = Window:CreateTab({
	Name = "Trolling",
	Icon = "sentiment_very_satisfied",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
	Name = "InstantKill",
	Description = "Needs a sword for it to work", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
    	end
})


local Button = Tab:CreateButton({
	Name = "infoViewer",
	Description = "''i got ur IP address''", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty31.lua"))()
    	end
})

local Tab = Window:CreateTab({
	Name = "Admins",
	Icon = "admin_panel_settings",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
	Name = "Infinite Yield",
	Description = "loads infinite Yield", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    	end
})

local Button = Tab:CreateButton({
	Name = "NamelessAdmin",
	Description = "Loads NamelessAdmin", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
    	end
})

local Button = Tab:CreateButton({
	Name = "NamelessAdminV2",
	Description = "Loads NamelessAdminV2", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
    	end
})

Tab:CreateDivider()

local Button = Tab:CreateButton({
	Name = "TerminalCmd",
	Description = "Try Our AdminPanel :D", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TCmd/refs/heads/main/TerminalCmd", true))()
    	end
})

local Tab = Window:CreateTab({
	Name = "Misc",
	Icon = "dashboard",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

-- Your UI Toggle
local Toggle = Tab:CreateToggle({
	Name = "TpKill",
	Description = "Teleports above a random Victim. Changes when they die.",
	CurrentValue = false,
	Callback = function(Value)
		if Value then
			startTeleporting()
		else
			stopTeleporting()
		end
	end
}, "Toggle")

local Toggle = Tab:CreateToggle({
    Name = "Auto Clicker",
    Description = "Automatically clicks for you",
    CurrentValue = false,
    Callback = function(Value)
        getgenv().autoClickerEnabled = Value
        if Value then
            spawn(function()
                while getgenv().autoClickerEnabled and task.wait(0.1) do
                    local player = game.Players.LocalPlayer
                    if player and player:GetMouse() then
                        mouse1click()
                    end
                end
            end)
        end
    end
}, "Toggle")

local Button = Tab:CreateButton({
	Name = "Shiftlock",
	Description = "ShiftLock Button", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://github.com/ltseverydayyou/uuuuuuu/blob/main/shiftlock?raw=true"))()
    	end
})

local Toggle = Tab:CreateToggle({
    Name = "Anti-AFK",
    Description = "Prevents you from being kicked for inactivity",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            getgenv().antiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                game:GetService("VirtualUser"):Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
                task.wait(1)
                game:GetService("VirtualUser"):Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            end)
        else
            if getgenv().antiAFKConnection then
                getgenv().antiAFKConnection:Disconnect()
            end
        end
    end
}, "Toggle")

local Tab = Window:CreateTab({
	Name = "Info",
	Icon = "info",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Paragraph = Tab:CreateParagraph({
	Title = "[ About ]",
	Text = "SilverWare Is a free Exploit with no KeySystems and it has so many features enough to destroy you're Victims"
})

Tab:CreateDivider()

local Paragraph = Tab:CreateParagraph({
	Title = "[ UpdateLog ]",
	Text = "Fixed Esp Delay | Bugs Fixed 2"
})

Luna:Notification({ 
	Title = "üç¥ [ Gui Finished Loading ] üç¥",
	Icon = "notifications_active",
	ImageSource = "Material",
	Content = "Made By Hmmm5650"
})
