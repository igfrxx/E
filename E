local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")

-- StoredVariables
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")

-- Configurations
local highlightEspEnabled = false
local nameEspEnabled = false
local boxEspEnabled = false
local teamCheckEnabled = true
local espColor = Color3.fromRGB(86, 171, 128)
local espObjects = {}

-- Function to safely get player from character
local function getPlayerFromCharacter(character)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character == character then
            return player
        end
    end
    return nil
end

-- Function to check if teams are enabled in the game
local function areTeamsEnabled()
    -- Check if the Teams service exists and has teams
    local success, teamCount = pcall(function() return #Teams:GetTeams() end)
    if not success then
        return false
    end
    
    if teamCount > 1 then
        return true
    end
    
    -- Check if any players are assigned to teams
    for _, player in ipairs(Players:GetPlayers()) do
        if player:IsA("Player") and player.Team and player.Team ~= Teams.Neutral then
            return true
        end
    end
    
    return false
end

-- Function to check if a player is an enemy
local function isEnemy(player)
    local localPlayer = Players.LocalPlayer
    if not localPlayer or not player or player == localPlayer then
        return false
    end
    
    -- If team check is disabled or teams aren't enabled in the game, treat everyone as enemy
    if not teamCheckEnabled or not areTeamsEnabled() then
        return true
    end
    
    -- If the local player has no team, treat everyone as enemy
    if not localPlayer.Team or localPlayer.Team == Teams.Neutral then
        return true
    end
    
    -- If the other player has no team, treat them as enemy
    if not player.Team then
        return true
    end
    
    -- Otherwise, check if they're on a different team
    return player.Team ~= localPlayer.Team
end

-- Function to create ESP
local function createEsp(player)
    if not player or not player:IsA("Player") or not player.Character then return end

    local character = player.Character
    if not character or not character.Parent then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoidRootPart or not humanoid then return end

    -- Remove existing ESP if it exists
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Parent then
                obj:Destroy()
            end
        end
        espObjects[player] = nil
    end

    -- Only create ESP for enemies
    if not isEnemy(player) then return end

    -- Create new ESP objects
    espObjects[player] = {}

    -- Highlight ESP
    if highlightEspEnabled then
        local highlight = Instance.new("Highlight")
        highlight.Name = "SilverWareHighlight"
        highlight.Adornee = character
        highlight.FillColor = espColor
        highlight.OutlineColor = espColor
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Parent = character
        table.insert(espObjects[player], highlight)
    end

    -- Name ESP
    if nameEspEnabled then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "SilverWareNameEsp"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Text = player.Name
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextStrokeTransparency = 0
        textLabel.TextColor3 = espColor
        textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        textLabel.TextScaled = true
        textLabel.Parent = billboard
        
        if humanoidRootPart and humanoidRootPart.Parent then
            billboard.Parent = humanoidRootPart
            table.insert(espObjects[player], billboard)
        else
            billboard:Destroy()
        end
    end

    -- Box ESP
    if boxEspEnabled then
        local box = Instance.new("BoxHandleAdornment")
        box.Name = "SilverWareBoxEsp"
        box.Adornee = humanoidRootPart
        box.AlwaysOnTop = true
        box.ZIndex = 10
        box.Size = humanoidRootPart.Size * 1.5
        box.Transparency = 0.5
        box.Color3 = espColor
        
        if humanoidRootPart and humanoidRootPart.Parent then
            box.Parent = humanoidRootPart
            table.insert(espObjects[player], box)
        else
            box:Destroy()
        end
    end
end

-- Function to update ESP color
local function updateEspColor(newColor)
    espColor = newColor
    for player, objects in pairs(espObjects) do
        if player and player:IsA("Player") then
            for _, obj in pairs(objects) do
                if obj and obj.Parent then
                    if obj:IsA("Highlight") then
                        obj.FillColor = newColor
                        obj.OutlineColor = newColor
                    elseif obj:IsA("BillboardGui") and obj:FindFirstChild("TextLabel") then
                        obj.TextLabel.TextColor3 = newColor
                    elseif obj:IsA("BoxHandleAdornment") then
                        obj.Color3 = newColor
                    end
                end
            end
        end
    end
end

-- Function to toggle ESP for all players
local function toggleEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        if player and player:IsA("Player") then
            createEsp(player)
        end
    end
end

-- Function to clear all ESP
local function clearEsp()
    for player, objects in pairs(espObjects) do
        if objects then
            for _, obj in pairs(objects) do
                if obj and obj.Parent then
                    obj:Destroy()
                end
            end
        end
    end
    espObjects = {}
end

-- Handle player respawns
local function onCharacterAdded(character, player)
    if not character or not character.Parent then return end
    
    -- Wait for character to fully load
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    local humanoid = character:WaitForChild("Humanoid", 5)
    
    if not humanoidRootPart or not humanoid then return end
    
    -- Check if ESP should be created
    if highlightEspEnabled or nameEspEnabled or boxEspEnabled then
        createEsp(player)
    end
    
    -- Handle future respawns
    humanoid.Died:Connect(function()
        -- Clean up ESP when player dies
        if espObjects[player] then
            for _, obj in pairs(espObjects[player]) do
                if obj and obj.Parent then
                    obj:Destroy()
                end
            end
            espObjects[player] = nil
        end
    end)
end

-- Player added/removed connections
local function onPlayerAdded(player)
    if not player or not player:IsA("Player") then return end
    
    -- Handle initial character
    player.CharacterAdded:Connect(function(character)
        onCharacterAdded(character, player)
    end)
    
    if player.Character then
        coroutine.wrap(onCharacterAdded)(player.Character, player)
    end
end

local function onPlayerRemoving(player)
    if not player or not player:IsA("Player") then return end
    
    -- Clean up ESP when player leaves
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Parent then
                obj:Destroy()
            end
        end
        espObjects[player] = nil
    end
end

-- Initialize for existing players
for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end

-- Connect future players
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Initialize for local player (in case they respawn)
if Players.LocalPlayer and Players.LocalPlayer.Character then
    onCharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer)
end

-- Hitbox Configuration variables
local hitboxEnabled = false
local hitboxSize = 10
local hitboxTransparency = 0.9
local hitboxColor = Color3.fromRGB(109, 110, 108)
local hitboxCoroutine = nil

-- Apply hitbox to a character
local function applyHitbox(character)
    if not character then return end
    
    -- Skip if this is the local player's character
    local player = Players:GetPlayerFromCharacter(character)
    if player and player == Players.LocalPlayer then
        return
    end
    
    -- Handle R15 characters differently
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local isR15 = humanoid and humanoid.RigType == Enum.HumanoidRigType.R15
    
    -- HumanoidRootPart modifications
    local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("UpperTorso")
    if rootPart then
        if not rootPart:FindFirstChild("OriginalSize") then
            local originalSize = Instance.new("Vector3Value")
            originalSize.Name = "OriginalSize"
            originalSize.Value = rootPart.Size
            originalSize.Parent = rootPart
            
            local originalCollide = Instance.new("BoolValue")
            originalCollide.Name = "OriginalCanCollide"
            originalCollide.Value = rootPart.CanCollide
            originalCollide.Parent = rootPart
        end
        
        rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        rootPart.Transparency = hitboxTransparency
        rootPart.Color = hitboxColor
        rootPart.Material = Enum.Material.ForceField
        rootPart.CanCollide = false  -- Always false regardless of alive state
        
        -- For R15, we need to adjust the other parts too
        if isR15 then
            local lowerTorso = character:FindFirstChild("LowerTorso")
            if lowerTorso then
                if not lowerTorso:FindFirstChild("OriginalSize") then
                    local originalSize = Instance.new("Vector3Value")
                    originalSize.Name = "OriginalSize"
                    originalSize.Value = lowerTorso.Size
                    originalSize.Parent = lowerTorso
                    
                    local originalCollide = Instance.new("BoolValue")
                    originalCollide.Name = "OriginalCanCollide"
                    originalCollide.Value = lowerTorso.CanCollide
                    originalCollide.Parent = lowerTorso
                end
                lowerTorso.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                lowerTorso.Transparency = hitboxTransparency
                lowerTorso.Color = hitboxColor
                lowerTorso.Material = Enum.Material.ForceField
                lowerTorso.CanCollide = false  -- Always false
            end
        end
    end
    
    -- Head modifications
    local head = character:FindFirstChild("Head")
    if head then
        if not head:FindFirstChild("OriginalSize") then
            local originalSize = Instance.new("Vector3Value")
            originalSize.Name = "OriginalSize"
            originalSize.Value = head.Size
            originalSize.Parent = head
            
            local originalCollide = Instance.new("BoolValue")
            originalCollide.Name = "OriginalCanCollide"
            originalCollide.Value = head.CanCollide
            originalCollide.Parent = head
        end
        
        head.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        head.Transparency = hitboxTransparency
        head.Color = hitboxColor
        head.Material = Enum.Material.ForceField
        head.CanCollide = false  -- Always false
        head.Massless = true
    end
    
    -- For R15, adjust other important parts
    if isR15 then
        local partsToAdjust = {"UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}
        for _, partName in ipairs(partsToAdjust) do
            local part = character:FindFirstChild(partName)
            if part then
                if not part:FindFirstChild("OriginalSize") then
                    local originalSize = Instance.new("Vector3Value")
                    originalSize.Name = "OriginalSize"
                    originalSize.Value = part.Size
                    originalSize.Parent = part
                    
                    local originalCollide = Instance.new("BoolValue")
                    originalCollide.Name = "OriginalCanCollide"
                    originalCollide.Value = part.CanCollide
                    originalCollide.Parent = part
                end
                
                part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                part.Transparency = hitboxTransparency
                part.Color = hitboxColor
                part.Material = Enum.Material.ForceField
                part.CanCollide = false  -- Always false
            end
        end
    end
end

-- Reset hitbox to original state
local function resetHitbox(character)
    if not character then return end
    
    -- Skip if this is the local player's character
    local player = Players:GetPlayerFromCharacter(character)
    if player and player == Players.LocalPlayer then
        return
    end
    
    -- Reset HumanoidRootPart
    local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("UpperTorso")
    if rootPart and rootPart:FindFirstChild("OriginalSize") then
        rootPart.Size = rootPart.OriginalSize.Value
        rootPart.Transparency = 1
        rootPart.Color = Color3.fromRGB(170, 170, 170) -- Default grey color
        rootPart.Material = Enum.Material.Plastic
        rootPart.CanCollide = rootPart:FindFirstChild("OriginalCanCollide") and rootPart.OriginalCanCollide.Value or true
    end
    
    -- Reset Head
    local head = character:FindFirstChild("Head")
    if head and head:FindFirstChild("OriginalSize") then
        head.Size = head.OriginalSize.Value
        head.Transparency = 0
        head.Color = Color3.fromRGB(170, 170, 170) -- Default grey color
        head.Material = Enum.Material.Plastic
        head.CanCollide = head:FindFirstChild("OriginalCanCollide") and head.OriginalCanCollide.Value or true
        head.Massless = false
    end
    
    -- Reset R15 parts
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local isR15 = humanoid and humanoid.RigType == Enum.HumanoidRigType.R15
    
    if isR15 then
        local partsToReset = {"LowerTorso", "UpperTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}
        for _, partName in ipairs(partsToReset) do
            local part = character:FindFirstChild(partName)
            if part and part:FindFirstChild("OriginalSize") then
                part.Size = part.OriginalSize.Value
                part.Transparency = 0
                part.Color = Color3.fromRGB(170, 170, 170) -- Default grey color
                part.Material = Enum.Material.Plastic
                part.CanCollide = part:FindFirstChild("OriginalCanCollide") and part.OriginalCanCollide.Value or true
            end
        end
    end
end

-- Apply hitboxes to all enemy players
local function applyHitboxesToAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if isEnemy(player) and player.Character then
            applyHitbox(player.Character)
        end
    end
end

-- Reset hitboxes on all players
local function resetHitboxesOnAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            resetHitbox(player.Character)
        end
    end
end

-- Track player characters for respawn/death events
local function trackPlayer(player)
    if not player then return end
    
    -- Handle character added (respawn)
    player.CharacterAdded:Connect(function(character)
        task.wait(1) -- Wait for character to fully load
        
        if hitboxEnabled then
            applyHitbox(character)  -- Always apply hitbox regardless of alive state
        end
    end)
    
    -- Handle existing character
    if player.Character and hitboxEnabled then
        applyHitbox(player.Character)  -- Always apply hitbox regardless of alive state
    end
end

-- Initialize tracking for all players
for _, player in ipairs(Players:GetPlayers()) do
    trackPlayer(player)
end

-- Player added/removed events
Players.PlayerAdded:Connect(trackPlayer)

-- Toggle system for hitboxes
local function toggleHitboxes(enabled)
    hitboxEnabled = enabled
    
    if enabled then
        applyHitboxesToAllPlayers()
        
        if not hitboxCoroutine then
            hitboxCoroutine = coroutine.create(function()
                while hitboxEnabled and task.wait(0.5) do
                    applyHitboxesToAllPlayers()
                end
            end)
            coroutine.resume(hitboxCoroutine)
        end
    else
        if hitboxCoroutine then
            coroutine.close(hitboxCoroutine)
            hitboxCoroutine = nil
        end
        resetHitboxesOnAllPlayers()
    end
end

-- FPS Counter
local fpsGui = Instance.new("ScreenGui")
fpsGui.Name = "FPSCounterGui"
fpsGui.ResetOnSpawn = false
fpsGui.Enabled = false
fpsGui.Parent = game:GetService("CoreGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 120, 0, 50)
frame.Position = UDim2.new(0, 10, 0, 10)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BackgroundTransparency = 1
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
frame.Parent = fpsGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 1, 0)
label.BackgroundTransparency = 1
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.Arcade
label.Text = "FPS: 0"
label.Parent = frame

-- FPS Update Loop
local fps = 0
local counter = 0
local lastTick = tick()
local fpsConnection = nil

local function updateFPS()
    counter += 1
    if tick() - lastTick >= 1 then
        fps = counter
        counter = 0
        lastTick = tick()
        label.Text = "FPS: " .. tostring(math.floor(fps))
    end
end

-- Function to toggle FPS counter
local function toggleFpsCounter(enable)
    if enable then
        if not fpsConnection then
            fpsConnection = RunService.RenderStepped:Connect(updateFPS)
        end
        fpsGui.Enabled = true
    else
        if fpsConnection then
            fpsConnection:Disconnect()
            fpsConnection = nil
        end
        fpsGui.Enabled = false
    end
end

-- Notification

local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "NotificationGui"
screenGui.Parent = gui
screenGui.ResetOnSpawn = false

-- Create a sound folder in SoundService for our notification sounds
local notificationSounds = Instance.new("Folder")
notificationSounds.Name = "NotificationSounds"
notificationSounds.Parent = SoundService

-- Sound IDs and configurations
local soundConfigs = {
    NotificationAppear = {id = 3023237993, volume = 0.1},
    NotificationDisappear = {id = 18595195017, volume = 0.1},
    NotificationHover = {id = 7218169592, volume = 0.1},
    NotificationClick = {id = 177266782, volume = 0.1},
    NotificationPulse = {id = 10066936758, volume = 0.1}
}
-- Function to play sounds
local function playSound(soundName)
    local config = soundConfigs[soundName]
    if not config then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://"..config.id
    sound.Volume = config.volume
    sound.Parent = notificationSounds
    sound:Play()
    
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

-- Notification function
function showNotification(title, message, duration, color)
    duration = duration or 5
    color = color or Color3.fromRGB(0, 170, 255)

    -- Play appear sound
    playSound("NotificationAppear")

    -- Main frame
    local frame = Instance.new("Frame")
    frame.Name = "Notification"
    frame.Size = UDim2.new(0.35, 0, 0, 70)
    frame.Position = UDim2.new(1, 10, 0.85, 0)
    frame.AnchorPoint = Vector2.new(1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.BackgroundTransparency = 0.8  -- Start more transparent for dramatic fade-in
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.ZIndex = 10
    frame.ClipsDescendants = true  -- For the ripple effect

    -- Shadow with initial scale for pop effect
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageTransparency = 0.9  -- Start more transparent
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame

    -- Rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    -- Accent line
    local accent = Instance.new("Frame")
    accent.Name = "Accent"
    accent.Size = UDim2.new(0, 0, 0, 2)  -- Start with 0 width for animation
    accent.Position = UDim2.new(0, 0, 0, 0)
    accent.BackgroundColor3 = color
    accent.BorderSizePixel = 0
    accent.ZIndex = frame.ZIndex + 1
    accent.Parent = frame

    -- Title with initial scale for bounce effect
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 180)
    titleLabel.TextTransparency = 1  -- Start invisible for fade-in
    titleLabel.TextSize = 15
    titleLabel.Font = Enum.Font.Code
    titleLabel.Size = UDim2.new(1, -40, 0, 18)
    titleLabel.Position = UDim2.new(0, 10, 0, 8)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.BackgroundTransparency = 1
    titleLabel.ZIndex = frame.ZIndex + 1
    titleLabel.Parent = frame

    -- Message
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Name = "Message"
    messageLabel.Text = message
    messageLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    messageLabel.TextTransparency = 1  -- Start invisible for fade-in
    messageLabel.TextSize = 14
    messageLabel.Font = Enum.Font.Code
    messageLabel.Size = UDim2.new(1, -20, 0, 35)
    messageLabel.Position = UDim2.new(0, 10, 0, 28)
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextYAlignment = Enum.TextYAlignment.Top
    messageLabel.BackgroundTransparency = 1
    messageLabel.ZIndex = frame.ZIndex + 1
    messageLabel.Parent = frame

    -- Close button with hover effects
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Text = "Ã—"
    closeButton.TextColor3 = Color3.fromRGB(180, 180, 180)
    closeButton.TextTransparency = 1  -- Start invisible for fade-in
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.Code
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 6)
    closeButton.BackgroundTransparency = 1
    closeButton.ZIndex = frame.ZIndex + 1
    closeButton.Parent = frame

    -- Add a subtle glow effect
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.Image = "rbxassetid://5028857084"
    glow.ImageColor3 = color
    glow.ImageTransparency = 1  -- Start invisible
    glow.ScaleType = Enum.ScaleType.Slice
    glow.SliceCenter = Rect.new(24, 24, 24, 24)
    glow.Size = UDim2.new(1, 40, 1, 40)
    glow.Position = UDim2.new(0.5, -20, 0.5, -20)
    glow.AnchorPoint = Vector2.new(0.5, 0.5)
    glow.BackgroundTransparency = 1
    glow.ZIndex = frame.ZIndex - 1
    glow.Parent = frame

    -- Add a ripple effect for when the notification appears
    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = Color3.new(1, 1, 1)
    ripple.BackgroundTransparency = 0.9
    ripple.ZIndex = frame.ZIndex + 2
    local rippleCorner = Instance.new("UICorner")
    rippleCorner.CornerRadius = UDim.new(1, 0)
    rippleCorner.Parent = ripple
    ripple.Parent = frame

    -- Pulse animation for accent line
    local pulseConnection
    local function startPulse()
        playSound("NotificationPulse")
        
        local targetColor = Color3.new(color.R * 1.2, color.G * 1.2, color.B * 1.2)
        local pulseIn = TweenService:Create(accent, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, true), {
            BackgroundColor3 = targetColor
        })
        pulseIn:Play()
    end

    -- Slide in animation with bounce
    local slideIn = TweenService:Create(frame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(1, -10, 0.85, 0),
        BackgroundTransparency = 0.1
    })
    
    -- Pop effect for shadow
    local shadowPop = TweenService:Create(shadow, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        ImageTransparency = 0.6,
        Size = UDim2.new(1, 30, 1, 30),
        Position = UDim2.new(0, -15, 0, -15)
    })
    
    -- Glow effect
    local glowFadeIn = TweenService:Create(glow, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
        ImageTransparency = 0.8
    })
    
    -- Ripple effect animation
    local rippleExpand = TweenService:Create(ripple, TweenInfo.new(0.6, Enum.EasingStyle.Quad), {
        Size = UDim2.new(2, 0, 2, 0),
        BackgroundTransparency = 1
    })
    
    -- Fade in content with slight delay between elements
    local fadeIn = TweenService:Create(titleLabel, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    local fadeIn2 = TweenService:Create(messageLabel, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    local fadeIn3 = TweenService:Create(closeButton, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
        TextTransparency = 0
    })
    
    -- Accent line grow animation with overshoot
    local accentGrow = TweenService:Create(accent, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 0, 2)
    })
    
    -- Frame fade in with slight scale effect
    local frameFadeIn = TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
        BackgroundTransparency = 0.1
    })

    -- Play animations in sequence with staggered timing
    slideIn:Play()
    shadowPop:Play()
    rippleExpand:Play()
    glowFadeIn:Play()
    
    -- Start ripple from center
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    
    task.wait(0.1)
    accentGrow:Play()
    frameFadeIn:Play()
    
    task.wait(0.15)
    fadeIn:Play()
    
    task.wait(0.05)
    fadeIn2:Play()
    
    task.wait(0.05)
    fadeIn3:Play()
    
    -- Start pulse animation after everything is shown
    task.delay(0.6, startPulse)
    
    -- Hover effect for the entire notification
    local hoverScale = 1.02
    frame.MouseEnter:Connect(function()
        playSound("NotificationHover")
        
        TweenService:Create(frame, TweenInfo.new(0.2), {
            Size = UDim2.new(0.35 * hoverScale, 0, 0, 70 * hoverScale)
        }):Play()
        TweenService:Create(shadow, TweenInfo.new(0.2), {
            Size = UDim2.new(1, 30 * hoverScale, 1, 30 * hoverScale),
            Position = UDim2.new(0, -15 * hoverScale, 0, -15 * hoverScale)
        }):Play()
    end)
    
    frame.MouseLeave:Connect(function()
        TweenService:Create(frame, TweenInfo.new(0.2), {
            Size = UDim2.new(0.35, 0, 0, 70)
        }):Play()
        TweenService:Create(shadow, TweenInfo.new(0.2), {
            Size = UDim2.new(1, 30, 1, 30),
            Position = UDim2.new(0, -15, 0, -15)
        }):Play()
    end)

    -- Close functionality with animations
    local closing = false
    local function close()
        if closing then return end
        closing = true
        
        playSound("NotificationDisappear")
        
        -- Stop pulse animation
        if pulseConnection then
            pulseConnection:Disconnect()
        end
        
        -- Create a new ripple for close effect
        local closeRipple = ripple:Clone()
        closeRipple.BackgroundTransparency = 0.95
        closeRipple.Size = UDim2.new(0, 0, 0, 0)
        closeRipple.Position = UDim2.new(
            UserInputService:GetMouseLocation().X / frame.AbsoluteSize.X,
            0,
            (UserInputService:GetMouseLocation().Y - frame.AbsolutePosition.Y) / frame.AbsoluteSize.Y,
            0
        )
        closeRipple.AnchorPoint = Vector2.new(0.5, 0.5)
        closeRipple.Parent = frame
        
        local rippleOut = TweenService:Create(closeRipple, TweenInfo.new(0.6, Enum.EasingStyle.Quad), {
            Size = UDim2.new(2, 0, 2, 0),
            BackgroundTransparency = 1
        })
        rippleOut:Play()
        rippleOut.Completed:Connect(function()
            closeRipple:Destroy()
        end)
        
        -- Shake effect when closing
        local shakeOffset = 5
        for i = 1, 3 do
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 + shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            TweenService:Create(frame, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                Position = UDim2.new(1, -10 - shakeOffset, 0.85, 0)
            }):Play()
            task.wait(0.05)
            shakeOffset = shakeOffset * 0.6  -- Reduce shake amount each time
        end
        
        -- Fade out content first
        local fadeOut = TweenService:Create(titleLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut2 = TweenService:Create(messageLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        local fadeOut3 = TweenService:Create(closeButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })
        
        fadeOut:Play()
        fadeOut2:Play()
        fadeOut3:Play()
        
        -- Then slide out the frame
        task.wait(0.15)
        local slideOut = TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Position = UDim2.new(1, 10, 0.85, 0),
            BackgroundTransparency = 0.8
        })
        
        -- Shrink accent line
        local accentShrink = TweenService:Create(accent, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 0, 0, 2)
        })
        
        -- Shadow fade out and shrink
        local shadowFadeOut = TweenService:Create(shadow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 0.9,
            Size = UDim2.new(1, 20, 1, 20),
            Position = UDim2.new(0, -10, 0, -10)
        })
        
        -- Glow fade out
        local glowFadeOut = TweenService:Create(glow, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            ImageTransparency = 1
        })
        
        slideOut:Play()
        accentShrink:Play()
        shadowFadeOut:Play()
        glowFadeOut:Play()
        
        slideOut.Completed:Wait()
        frame:Destroy()
    end

    closeButton.MouseButton1Click:Connect(function()
        playSound("NotificationClick")
        close()
    end)
    
    -- Enhanced close button hover effects
    closeButton.MouseEnter:Connect(function()
        playSound("NotificationHover")
        
        TweenService:Create(closeButton, TweenInfo.new(0.1), {
            TextColor3 = Color3.new(1, 1, 1),
            Rotation = 90,
            TextSize = 22
        }):Play()
    end)
    
    closeButton.MouseLeave:Connect(function()
        TweenService:Create(closeButton, TweenInfo.new(0.1), {
            TextColor3 = Color3.fromRGB(180, 180, 180),
            Rotation = 0,
            TextSize = 20
        }):Play()
    end)

    -- Auto-close after duration
    task.delay(duration, function()
        close()
    end)
end

-- Example usage with different animations
showNotification("Hello :)", "Made By Hmmm5650", 3, Color3.fromRGB(0, 170, 255))

-- [ LoadsScriptResources ]
pcall(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LoadResources/refs/heads/main/ResSourcesLoaderSource", true))()
    warn("StartedScript")
end)

local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()
local Window = Luna:CreateWindow({
    Name = "SilverWareðŸ´(v0.2)",
    Subtitle = "SilverWare On Top!!",
    LogoID = "98445694743887",
    LoadingEnabled = true,
    LoadingTitle = "Starting SilverWareðŸ´",
    LoadingSubtitle = "[ Ver, 0.2 ]",
    ConfigSettings = {
        RootFolder = nil,
        ConfigFolder = "SliverWareConfig"
    },
    KeySystem = false
})

local Tab = Window:CreateTab({
    Name = "Settings",
    Icon = "settings",
    ImageSource = "Material",
    ShowTitle = true
})

local Button = Tab:CreateButton({
	Name = "Antikick",
	Description = "Deletes AntiCheat", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/AntkickLol/refs/heads/main/Antikicklol"))()
    	end
})

local Button = Tab:CreateButton({
	Name = "AntiLag",
	Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://pastebin.com/raw/zJztwUg1", true))()
    	end
})

-- FullBright ToggleVariable
local Lighting = game:GetService("Lighting")

-- Store original lighting settings to restore them later
local originalSettings = {
	Brightness = Lighting.Brightness,
	ClockTime = Lighting.ClockTime,
	FogEnd = Lighting.FogEnd,
	GlobalShadows = Lighting.GlobalShadows,
	Ambient = Lighting.Ambient
}

local Toggle = Tab:CreateToggle({
	Name = "FullBright",
	Description = nil,
	CurrentValue = false,
	Callback = function(Value)
		if Value then
			Lighting.Brightness = 5
			Lighting.ClockTime = 12
			Lighting.FogEnd = 100000
			Lighting.GlobalShadows = false
			Lighting.Ambient = Color3.new(1, 1, 1)
		else
			-- Restore original lighting settings
			for prop, val in pairs(originalSettings) do
				Lighting[prop] = val
			end
		end
	end
}, "Toggle")

local Button = Tab:CreateButton({
    Name = "Reset WalkSpeed",
    Description = "Resets your WalkSpeed to default (16)",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = 16
        end
    end
})

local Slider = Tab:CreateSlider({
    Name = "WalkSpeed Slider",
    Range = {0, 200},
    Increment = 5,
    CurrentValue = 16,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = Value
        end
    end
}, "WalkSpeedSlider")

local Button = Tab:CreateButton({
	Name = "Show Console",
	Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         game:GetService("StarterGui"):SetCore("DevConsoleVisible",true)
    	end
})

Tab:CreateDivider()

local Tab = Window:CreateTab({
	Name = "PlayerList",
	Icon = "group",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
    Name = "Copy Player Username",
    Description = "Click to show player list",
    Callback = function()
        -- Clear any existing buttons (if needed)
        -- (Depends on your UI library, some may require manual cleanup)
        
        -- Get all players
        local players = game:GetService("Players"):GetPlayers()
        
        -- Create a button for each player
        for _, player in ipairs(players) do
            Tab:CreateButton({
                Name = player.Name,
                Description = "Click to copy username",
                Callback = function()
                    -- Copy username to clipboard
                    if setclipboard then
                        setclipboard(player.Name)
                    else
                        -- Fallback for non-exploit environments (Roblox Studio)
                        print("[Copied] " .. player.Name)
                    end
                    
                    -- Optional: Notify the user
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = "Copied!",
                        Text = player.Name .. " copied to clipboard",
                        Duration = 3,
                    })
                end
            })
        end
    end
})

-- Create the Visuals tab
local Tab = Window:CreateTab({
    Name = "Visuals",
    Icon = "visibility",
    ImageSource = "Material",
    ShowTitle = true
})

-- Highlight ESP Toggle
local Toggle = Tab:CreateToggle({
    Name = "HighlightEsp",
    Description = "Highlights players with a colored outline",
    CurrentValue = false,
    Callback = function(Value)
        highlightEspEnabled = Value
        if Value then
            toggleEsp()
        else
            clearEsp()
            if nameEspEnabled or boxEspEnabled then
                toggleEsp()
            end
        end
    end
}, "Toggle")

-- Name ESP Toggle
local Toggle = Tab:CreateToggle({
    Name = "NameEsp",
    Description = "Shows player names above their heads",
    CurrentValue = false,
    Callback = function(Value)
        nameEspEnabled = Value
        if Value then
            toggleEsp()
        else
            clearEsp()
            if highlightEspEnabled or boxEspEnabled then
                toggleEsp()
            end
        end
    end
}, "Toggle")

-- Box ESP Toggle
local Toggle = Tab:CreateToggle({
    Name = "BoxEsp",
    Description = "Draws a box around players",
    CurrentValue = false,
    Callback = function(Value)
        boxEspEnabled = Value
        if Value then
            toggleEsp()
        else
            clearEsp()
            if highlightEspEnabled or nameEspEnabled then
                toggleEsp()
            end
        end
    end
}, "Toggle")

-- Color Picker
local ColorPicker = Tab:CreateColorPicker({
    Name = "Esp Color",
    Color = Color3.fromRGB(86, 171, 128),
    Flag = "ColorPicker1",
    Callback = function(Value)
        updateEspColor(Value)
    end
}, "ColorPicker")

-- Initialize ESP for existing players if any toggle is enabled
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        wait(1) -- Wait for character to fully load
        if highlightEspEnabled or nameEspEnabled or boxEspEnabled then
            createEsp(player)
        end
    end)
end)

-- Initialize ESP for existing players
for _, player in ipairs(Players:GetPlayers()) do
    if player.Character and (highlightEspEnabled or nameEspEnabled or boxEspEnabled) then
        createEsp(player)
    end
    player.CharacterAdded:Connect(function(character)
        wait(1) -- Wait for character to fully load
        if highlightEspEnabled or nameEspEnabled or boxEspEnabled then
            createEsp(player)
        end
    end)
end

local Slider = Tab:CreateSlider({
    Name = "FOV Slider",
    Range = {0, 120},
    Increment = 1,
    CurrentValue = 70,
    Callback = function(Value)
        game.Workspace.CurrentCamera.FieldOfView = Value
    end
}, "FOVSlider")

local Tab = Window:CreateTab({
	Name = "Aimlock",
	Icon = "gps_fixed",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Toggle = Tab:CreateToggle({
    Name = "StartAimlock",
    Description = "Boots Up Aimlock",
    CurrentValue = false,
    Callback = function(Value)
        -- Store references to all the UI elements
        if not _G.AimlockUI then
            _G.AimlockUI = {
                Inputs = {},
                ColorPicker = nil,
                ScreenGui = nil
            }
        end
        
        if Value then
            -- Create the aimlock GUI if it doesn't exist
            if not _G.AimlockUI.ScreenGui or not _G.AimlockUI.ScreenGui.Parent then
                -- Get required services
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                local UserInputService = game:GetService("UserInputService")
                local TweenService = game:GetService("TweenService")

                -- Get local player
                local localPlayer = Players.LocalPlayer
                local playerGui = localPlayer:WaitForChild("PlayerGui")

                -- Create UI elements
                local screenGui = Instance.new("ScreenGui")
                screenGui.Parent = playerGui
                screenGui.ResetOnSpawn = false
                screenGui.Name = "AimLockUiLuau"
                _G.AimlockUI.ScreenGui = screenGui

                -- Control panel
                local controlPanel = Instance.new("Frame")
                controlPanel.Size = UDim2.new(0, 120, 0, 50)
                controlPanel.Position = UDim2.new(0, 20, 0, 20)
                controlPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                controlPanel.BackgroundTransparency = 0.3
                controlPanel.Active = true
                controlPanel.Parent = screenGui

                -- Round corners
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0.3, 0)
                corner.Parent = controlPanel

                -- Toggle button
                local toggleButton = Instance.new("TextButton")
                toggleButton.Size = UDim2.new(1, 0, 1, 0)
                toggleButton.Text = "AimLock: OFF"
                toggleButton.BackgroundTransparency = 1
                toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                toggleButton.TextSize = 14
                toggleButton.Font = Enum.Font.Gotham
                toggleButton.Parent = controlPanel

                -- Highlight when active
                local outline = Instance.new("UIStroke")
                outline.Thickness = 2
                outline.Color = Color3.fromRGB(0, 255, 0)
                outline.Enabled = false
                outline.Parent = controlPanel

                -- Target indicator
                local targetIndicator = Instance.new("Frame")
                targetIndicator.Size = UDim2.new(0, 150, 0, 150)
                targetIndicator.Position = UDim2.new(0.5, 0, 0.5, 0)
                targetIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
                targetIndicator.BackgroundTransparency = 1
                targetIndicator.Parent = screenGui

                local targetOutline = Instance.new("UIStroke")
                targetOutline.Thickness = 2
                targetOutline.Color = Color3.fromRGB(255, 0, 0)
                targetOutline.Transparency = 0.7
                targetOutline.Parent = targetIndicator

                local targetCorner = Instance.new("UICorner")
                targetCorner.CornerRadius = UDim.new(1, 0)
                targetCorner.Parent = targetIndicator

                -- Toggle functionality
                local aimAssistActive = false
                local smoothness = 0.3 -- Adjust this for smoother/stronger aim
                local maxDistance = 1000 -- Max distance to target
                local fovSize = 150 -- Field of view size

                toggleButton.MouseButton1Click:Connect(function()
                    aimAssistActive = not aimAssistActive
                    outline.Enabled = aimAssistActive
                    toggleButton.Text = aimAssistActive and "AimLock: ON" or "AimLock: OFF"
                    
                    -- Visual feedback
                    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local tween = TweenService:Create(
                        controlPanel,
                        tweenInfo,
                        {BackgroundColor3 = aimAssistActive and Color3.fromRGB(40, 40, 40) or Color3.fromRGB(30, 30, 30)}
                    )
                    tween:Play()
                end)

                -- Enemy check function
                local function isEnemyForAimAssist(player)
                    if player == localPlayer then return false end
                    if not player.Character then return false end
                    
                    if game:GetService("Teams") and #game:GetService("Teams"):GetTeams() > 1 then
                        local localTeam = localPlayer.Team
                        local playerTeam = player.Team
                        return localTeam ~= nil and playerTeam ~= nil and localTeam ~= playerTeam
                    else
                        return true -- Assume all players are enemies in non-team games
                    end
                end

                -- Visibility check function
                local function isVisible(targetPosition, character)
                    local localCharacter = localPlayer.Character
                    if not localCharacter then return false end
                    
                    local rootPart = localCharacter:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return false end
                    
                    local direction = (targetPosition - rootPart.Position).Unit
                    local ray = Ray.new(rootPart.Position + direction * 2, direction * maxDistance)
                    
                    local ignoreList = {localCharacter}
                    local hitPart, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                    
                    if hitPart then
                        local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
                        return hitCharacter == character
                    end
                    return false
                end

                -- Find best target function
                local function findBestTarget()
                    local bestTarget = nil
                    local closestDistance = math.huge
                    local localCharacter = localPlayer.Character
                    
                    if not localCharacter then return nil end
                    
                    local rootPart = localCharacter:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return nil end
                    
                    local camera = workspace.CurrentCamera
                    if not camera then return nil end
                    
                    local targetCenter = targetIndicator.AbsolutePosition + (targetIndicator.AbsoluteSize / 2)
                    local targetRadius = fovSize / 2

                    for _, player in pairs(Players:GetPlayers()) do
                        if isEnemyForAimAssist(player) and player.Character then
                            local character = player.Character
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if humanoid and humanoid.Health <= 0 then continue end
                            
                            local enemyRoot = character:FindFirstChild("HumanoidRootPart")
                            local head = character:FindFirstChild("Head")
                            
                            if enemyRoot then
                                local screenPosition, onScreen = camera:WorldToScreenPoint(enemyRoot.Position)
                                if onScreen then
                                    local distanceFromCenter = (Vector2.new(screenPosition.X, screenPosition.Y) - targetCenter).Magnitude
                                    local distanceFromPlayer = (rootPart.Position - enemyRoot.Position).Magnitude
                                    
                                    if distanceFromCenter <= targetRadius 
                                       and distanceFromPlayer <= maxDistance 
                                       and distanceFromCenter < closestDistance 
                                       and isVisible(enemyRoot.Position, character) then
                                        
                                        closestDistance = distanceFromCenter
                                        bestTarget = {
                                            player = player,
                                            root = enemyRoot,
                                            head = head
                                        }
                                    end
                                end
                            end
                        end
                    end
                    
                    return bestTarget
                end

                -- Aim assist functionality
                local aimAssistConnection
                aimAssistConnection = RunService.RenderStepped:Connect(function()
                    if aimAssistActive then
                        local target = findBestTarget()
                        
                        if target and target.root then
                            local camera = workspace.CurrentCamera
                            if camera then
                                -- Prioritize head if available
                                local targetPosition = target.head and target.head.Position or target.root.Position
                                local cameraPosition = camera.CFrame.Position
                                local targetCFrame = CFrame.new(cameraPosition, targetPosition)
                                
                                -- Smooth aiming
                                camera.CFrame = camera.CFrame:Lerp(targetCFrame, smoothness)
                                
                                -- Visual feedback
                                targetOutline.Color = Color3.fromRGB(0, 255, 0)
                            end
                        else
                            -- Reset visual feedback when no target
                            targetOutline.Color = Color3.fromRGB(255, 0, 0)
                        end
                    end
                end)

                -- Draggable UI functionality
                local isDragging = false
                local dragStartPosition = Vector2.new(0, 0)
                local dragStartOffset = UDim2.new(0, 0, 0, 0)

                controlPanel.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        isDragging = true
                        dragStartPosition = input.Position
                        dragStartOffset = controlPanel.Position
                        
                        -- Visual feedback
                        controlPanel.BackgroundTransparency = 0.2
                    end
                end)

                controlPanel.InputChanged:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
                        local dragDelta = input.Position - dragStartPosition
                        controlPanel.Position = UDim2.new(
                            dragStartOffset.X.Scale, 
                            dragStartOffset.X.Offset + dragDelta.X, 
                            dragStartOffset.Y.Scale, 
                            dragStartOffset.Y.Offset + dragDelta.Y
                        )
                    end
                end)

                UserInputService.InputEnded:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        isDragging = false
                        controlPanel.BackgroundTransparency = 0.3
                    end
                end)

                -- Cleanup when character respawns
                localPlayer.CharacterAdded:Connect(function()
                    if not screenGui:IsDescendantOf(playerGui) then
                        screenGui.Parent = playerGui
                    end
                end)

                -- Store connection for cleanup
                _G.AimlockUI.AimAssist = {
                    Connection = aimAssistConnection,
                    TargetIndicator = targetIndicator,
                    TargetOutline = targetOutline,
                    Smoothness = smoothness,
                    FOVSize = fovSize,
                    MaxDistance = maxDistance,
                    Toggle = function()
                        aimAssistActive = not aimAssistActive
                        outline.Enabled = aimAssistActive
                        toggleButton.Text = aimAssistActive and "AimLock: ON" or "AimLock: OFF"
                    end,
                    Destroy = function()
                        aimAssistConnection:Disconnect()
                        screenGui:Destroy()
                        _G.AimlockUI.AimAssist = nil
                    end
                }
            else
                -- If GUI exists but is hidden, show it
                _G.AimlockUI.ScreenGui.Enabled = true
            end
        else
            -- Hide the GUI when toggle is off
            if _G.AimlockUI.ScreenGui then
                _G.AimlockUI.ScreenGui.Enabled = false
            end
        end
    end
}, "Toggle")

-- Input for changing aimlock circle size
local Input1 = Tab:CreateInput({
    Name = "Fov Size",
    Description = nil,
    PlaceholderText = "150",
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 4,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local newSize = tonumber(Text)
            if newSize > 10 and newSize < 1000 then
                _G.AimlockUI.AimAssist.TargetIndicator.Size = UDim2.new(0, newSize, 0, newSize)
                _G.AimlockUI.AimAssist.FOVSize = newSize
            end
        end
    end
}, "Input1")

-- Input for changing aimlock circle transparency
local Input2 = Tab:CreateInput({
    Name = "Fov Transparency",
    Description = nil,
    PlaceholderText = "(0-1)",
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local transparency = tonumber(Text)
            if transparency >= 0 and transparency <= 1 then
                _G.AimlockUI.AimAssist.TargetOutline.Transparency = transparency
            end
        end
    end
}, "Input2")

-- Input for changing aimlock strength
local Input3 = Tab:CreateInput({
    Name = "Aimlock Strength",
    Description = nil,
    PlaceholderText = "(0.3)",
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        if _G.AimlockUI and _G.AimlockUI.AimAssist and tonumber(Text) then
            local strength = tonumber(Text)
            if strength >= 0.1 and strength <= 1 then
                _G.AimlockUI.AimAssist.Smoothness = strength
            end
        end
    end
}, "Input3")

-- Color picker for changing aimlock circle color
local ColorPicker = Tab:CreateColorPicker({
    Name = "FovColor",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = "AimlockColorPicker",
    Callback = function(Value)
        if _G.AimlockUI and _G.AimlockUI.AimAssist then
            _G.AimlockUI.AimAssist.TargetOutline.Color = Value
        end
    end
}, "ColorPicker")

local Tab = Window:CreateTab({
    Name = "Hitbox Expansion",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create the UI elements
local Toggle = Tab:CreateToggle({
    Name = "Hitbox Expander",
    Description = nil,
    CurrentValue = false,
    Callback = function(Value)
        toggleHitboxes(Value)
    end
}, "Toggle")

local SizeInput = Tab:CreateInput({
    Name = "Hitbox Size",
    Description = nil,
    PlaceholderText = "(1-50)",
    CurrentValue = tostring(hitboxSize),
    Numeric = true,
    MaxCharacters = 2,
    Enter = true,
    Callback = function(Text)
        local newSize = tonumber(Text)
        if newSize and newSize >= 1 and newSize <= 50 then
            hitboxSize = newSize
            if hitboxEnabled then
                applyHitboxesToAllPlayers()
            end
        end
    end
}, "Input")

local TransparencyInput = Tab:CreateInput({
    Name = "Hitbox Transparency",
    Description = nil,
    PlaceholderText = "(0-1)",
    CurrentValue = tostring(hitboxTransparency),
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        local newTransparency = tonumber(Text)
        if newTransparency and newTransparency >= 0 and newTransparency <= 1 then
            hitboxTransparency = newTransparency
            if hitboxEnabled then
                applyHitboxesToAllPlayers()
            end
        end
    end
}, "Input")

local ColorPicker = Tab:CreateColorPicker({
    Name = "HitboxColor",
    Color = hitboxColor,
    Flag = "HitboxColor",
    Callback = function(Value)
        hitboxColor = Value
        if hitboxEnabled then
            applyHitboxesToAllPlayers()
        end
    end
}, "ColorPicker")

-- Cleanup function
local function cleanup()
    -- Clean up hitboxes
    resetHitboxesOnAllPlayers()
    
    -- Clean up coroutine
    if hitboxCoroutine then
        coroutine.close(hitboxCoroutine)
        hitboxCoroutine = nil
    end
end

-- Store cleanup function for external access
getgenv().HitbloxCleanup = cleanup

local Tab = Window:CreateTab({
	Name = "Trolling",
	Icon = "sentiment_very_satisfied",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
	Name = "InstantKill",
	Description = "Needs a sword for it to work", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/InstantKillig/refs/heads/main/Coolkillguithingy", true))()
    	end
})


local Button = Tab:CreateButton({
	Name = "infoViewer",
	Description = "''i got ur IP address''", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty31.lua"))()
    	end
})

local Tab = Window:CreateTab({
	Name = "Admins",
	Icon = "admin_panel_settings",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Button = Tab:CreateButton({
	Name = "Infinite Yield",
	Description = "loads infinite Yield", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    	end
})

local Button = Tab:CreateButton({
	Name = "NamelessAdmin",
	Description = "Loads NamelessAdmin", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Nameless-Admin-Official-15022"))()
    	end
})

local Button = Tab:CreateButton({
	Name = "NamelessAdminV2",
	Description = "Loads NamelessAdminV2", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Nameless-admin-14114"))()
    	end
})

local Button = Tab:CreateButton({
	Name = "TerminalCmd",
	Description = "Try Our AdminPanel :D", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TCmd/refs/heads/main/TerminalCmd", true))()
    	end
})

local Tab = Window:CreateTab({
	Name = "Misc",
	Icon = "dashboard",
	ImageSource = "Material",
	ShowTitle = true -- This will determine whether the big header text in the tab will show
})

-- In your Toggle callback:
local Toggle = Tab:CreateToggle({
    Name = "Show FPSCounter",
    Description = nil,
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            fpsGui.Enabled = true
            -- Only create a new connection if one doesn't exist
            if not fpsConnection then
                fpsConnection = RunService.RenderStepped:Connect(updateFPS)
            end
        else
            fpsGui.Enabled = false
            -- Disconnect the connection if it exists
            if fpsConnection then
                fpsConnection:Disconnect()
                fpsConnection = nil
            end
        end
    end
}, "Toggle")

local Button = Tab:CreateButton({
	Name = "BloxStrap",
	Description = "bloxStrap from temu", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet('https://raw.githubusercontent.com/qwertyui-is-back/Bloxstrap/refs/heads/main/loader.lua'))()
    	end
})

local Button = Tab:CreateButton({
	Name = "Shiftlock",
	Description = "ShiftLock Button", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    	Callback = function()
         loadstring(game:HttpGet("https://github.com/ltseverydayyou/uuuuuuu/blob/main/shiftlock?raw=true"))()
    	end
})

Luna:Notification({ 
	Title = "ðŸ´ [ Gui Finished Loading ] ðŸ´",
	Icon = "notifications_active",
	ImageSource = "Material",
	Content = "Have Fun ;)"
})
